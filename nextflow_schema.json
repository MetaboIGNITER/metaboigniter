{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "https://raw.githubusercontent.com/nf-core/metaboigniter/master/nextflow_schema.json",
    "title": "nf-core/metaboigniter pipeline parameters",
    "description": "Get your metabolomics analysis up and running",
    "type": "object",
    "definitions": {
        "global_options": {
            "title": "Global options",
            "type": "object",
            "description": "General options that affect the whole pipeline",
            "default": "",
            "properties": {
                "outdir": {
                    "type": "string",
                    "description": "Output directory for results",
                    "default": "./results",
                    "fa_icon": "fas fa-folder-open"
                },
                "email": {
                    "type": "string",
                    "description": "Email address for completion summary",
                    "fa_icon": "fas fa-envelope",
                    "help_text": "An email address to send a summary email to when the pipeline is completed.",
                    "pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$"
                }
            },
            "fa_icon": "fas fa-globe"
        },
        "internal_library_quantification_and_identification_parameters_negative_mode": {
            "title": "Internal library quantification and identification parameters (negative mode)",
            "type": "object",
            "description": "Parameters used to tune library creation (only set if you want to do library idnetification)",
            "default": "",
            "properties": {
                "quantification_openms_xcms_library_neg": {
                    "type": "string",
                    "default": "xcms",
                    "description": "set whether you want to do quantification with OpenMS (openms) or XCMS (xcms) in negative ionization  (for library)",
                    "enum": [
                        "xcms",
                        "openms"
                    ]
                },
                "performIPO_library_neg": {
                    "type": "string",
                    "default": "none",
                    "description": "Controls how to perform IPO",
                    "help_text": "Possible values:\n* `none`: don't perform IPO\n* `global`: performs IPO on all or selected number of samples\n* `local`: performs IPO on individual samples one at the time",
                    "enum": [
                        "none",
                        "global",
                        "local"
                    ]
                },
                "ipo_methodXset_library_neg": {
                    "type": "string",
                    "default": "centWave",
                    "description": "Quantification methods for IPO",
                    "help_text": "Only centWave is supported at this stage."
                },
                "ipo_noise_l_library_neg": {
                    "type": "integer",
                    "default": 1000,
                    "description": "lowest level of noise"
                },
                "ipo_noise_h_library_neg": {
                    "type": "integer",
                    "description": "highest level of noise"
                },
                "ipo_snthresh_l_library_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "lowest level of signal to noise threshold"
                },
                "ipo_snthresh_h_library_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "highest level of signal to noise threshold"
                },
                "ipo_mzCenterFun_library_neg": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function for centering the mz"
                },
                "ipo_integrate_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method",
                    "help_text": "If `=1` peak limits are found through descent on the mexican hat filtered data, if `=2` the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "ipo_fitgauss_library_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitted"
                },
                "ipo_min_peakwidth_l_library_neg": {
                    "type": "integer",
                    "default": 12,
                    "description": "lower minimum width of peaks"
                },
                "ipo_min_peakwidth_h_library_neg": {
                    "type": "integer",
                    "default": 28,
                    "description": "higher minimum width of peaks"
                },
                "ipo_max_peakwidth_l_library_neg": {
                    "type": "integer",
                    "default": 35,
                    "description": "lower maximum width of peaks"
                },
                "ipo_max_peakwidth_h_library_neg": {
                    "type": "integer",
                    "default": 65,
                    "description": "higher maximum width of peaks"
                },
                "ipo_ppm_l_library_neg": {
                    "type": "integer",
                    "default": 17,
                    "description": "lower ppm mass deviation"
                },
                "ipo_ppm_h_library_neg": {
                    "type": "integer",
                    "default": 32,
                    "description": "higher ppm mass deviation"
                },
                "ipo_mzdiff_l_library_neg": {
                    "type": "number",
                    "default": -0.001,
                    "description": "lower minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_mzdiff_h_library_neg": {
                    "type": "number",
                    "default": 0.01,
                    "description": "higher minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_charge_camera_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "maximum charge of molecules (only used in individual setting)"
                },
                "ipo_max_ppm_camera_library_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm mass deviation for adducts (only used in individual setting)"
                },
                "ipo_prefilter_l_l_library_neg": {
                    "type": "integer",
                    "default": 3,
                    "description": "lower value of K in 'prefilter_library_neg=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_library_neg= 'I'."
                },
                "ipo_prefilter_l_h_library_neg": {
                    "type": "integer",
                    "default": 3,
                    "description": "higher value of K in 'prefilter_library_neg=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_library_neg= 'I'."
                },
                "ipo_prefilter_h_l_library_neg": {
                    "type": "integer",
                    "default": 100,
                    "description": "lower I in prefilter"
                },
                "ipo_prefilter_h_h_library_neg": {
                    "type": "integer",
                    "default": 100,
                    "description": "higher I in prefilter"
                },
                "ipo_ncores_library_neg": {
                    "type": "integer",
                    "default": 5,
                    "description": "number of cores used in IPO"
                },
                "ipo_gapInit_l_library_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "lower Penalty for Gap opening"
                },
                "ipo_gapInit_h_library_neg": {
                    "type": "number",
                    "default": 0.4,
                    "description": "higher Penalty for Gap opening"
                },
                "ipo_gapExtend_l_library_neg": {
                    "type": "number",
                    "default": 2.1,
                    "description": "lower Penalty for Gap enlargement"
                },
                "ipo_gapExtend_h_library_neg": {
                    "type": "number",
                    "default": 2.7,
                    "description": "higher Penalty for Gap enlargement"
                },
                "ipo_profStep_l_library_neg": {
                    "type": "number",
                    "default": 0.7,
                    "description": "lower step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_profStep_h_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_response_l_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_response_h_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_factorDiag_l_library_neg": {
                    "type": "integer",
                    "default": 2,
                    "description": "lower Local weighting applied to diagonal moves in alignment."
                },
                "ipo_factorDiag_h_library_neg": {
                    "type": "integer",
                    "default": 2,
                    "description": "higher Local weighting applied to diagonal moves in alignment."
                },
                "ipo_factorGap_l_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Local weighting applied to gap moves in alignment."
                },
                "ipo_factorGap_h_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Local weighting applied to gap moves in alignment."
                },
                "ipo_localAlignment_library_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "Local rather than global alignment"
                },
                "ipo_bw_l_library_neg": {
                    "type": "integer",
                    "default": 22,
                    "description": "lower bandwidth (consider something like retention time differences)"
                },
                "ipo_bw_h_library_neg": {
                    "type": "integer",
                    "default": 38,
                    "description": "higher bandwidth (consider something like retention time differences)"
                },
                "ipo_minfrac_l_library_neg": {
                    "type": "number",
                    "default": 0.3,
                    "description": "lower minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minfrac_h_library_neg": {
                    "type": "number",
                    "default": 0.7,
                    "description": "higher minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_mzwid_l_library_neg": {
                    "type": "number",
                    "default": 0.015,
                    "description": "lower mz width (mz differences)"
                },
                "ipo_mzwid_h_library_neg": {
                    "type": "number",
                    "default": 0.035,
                    "description": "higher mz width (mz differences)"
                },
                "ipo_minsamp_l_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minsamp_h_library_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_max_l_library_neg": {
                    "type": "integer",
                    "default": 50,
                    "description": "lower maximum number of groups to identify in a single m/z slice"
                },
                "ipo_max_h_library_neg": {
                    "type": "integer",
                    "default": 50,
                    "description": "higher maximum number of groups to identify in a single m/z slice"
                },
                "ipo_distFunc_library_neg": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)"
                },
                "ipo_methodRT_library_neg": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "Only obiwarp is supported"
                },
                "masstrace_ppm_library_neg_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "mass trace deviation in ppm"
                },
                "peakwidthlow_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 5,
                    "description": "lower width of peaks"
                },
                "peakwidthhigh_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 30,
                    "description": "highest width of peaks"
                },
                "noise_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 1000,
                    "description": "level of noise"
                },
                "mzdiff_quant_library_neg_xcms": {
                    "type": "number",
                    "default": -0.001,
                    "description": "minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "snthresh_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "signal to noise ratio cutoff, definition see below."
                },
                "prefilter_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 3,
                    "description": "K in 'prefilter=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >= 'I'."
                },
                "value_of_prefilter_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 100,
                    "description": "I in prefilter"
                },
                "mzCenterFun_quant_library_neg_xcms": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function to calculate the m/z center of the feature: 'wMean' intensity weighted mean of the feature m/z values, 'mean' mean of the feature m/z values, 'apex' use m/z value at peak apex, 'wMeanApex3' intensity weighted mean of the m/z value at peak apex and the m/z value left and right of it, 'meanApex3' mean of the m/z value at peak apex and the m/z value left and right of it."
                },
                "integrate_quant_library_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "fitgauss_quant_library_neg_xcms": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitted"
                },
                "phenodatacolumn_quant_library_neg": {
                    "type": "string",
                    "default": "Class",
                    "description": "name of the column in the phenotype_design_library_neg showing class information of the samples"
                },
                "sampleclass_quant_library_neg_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "A name for the class of sample"
                },
                "sigma_group_library_neg_camera": {
                    "type": "integer",
                    "default": 8,
                    "description": "sigma value for grouping the peaks across chromatogram"
                },
                "perfwhm_group_library_neg_camera": {
                    "type": "number",
                    "default": 0.6,
                    "description": "full width at half maximum for finding overlaping peaks"
                },
                "intval_group_library_neg_camera": {
                    "type": "string",
                    "default": "maxo",
                    "description": "which intensity value to use"
                },
                "ppm_findaddcuts_library_neg_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation between theoritical adduct mass and the experimental one"
                },
                "polarity_findaddcuts_library_neg_camera": {
                    "type": "string",
                    "default": "negative",
                    "description": "this has to be negative (for testing only)!"
                },
                "maxcharge_findisotopes_library_neg_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of changes to consider (most often 1 is enough)"
                },
                "ppm_mapmsmstocamera_library_neg_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation when mapping MS2 parent ion to a mass trace"
                },
                "rt_mapmsmstocamera_library_neg_msnbase": {
                    "type": "integer",
                    "default": 5,
                    "description": "rt difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace)"
                }
            },
            "help_text": "Please set the parameters needed for finding the mass traces for the library. These more or less follow the same design as the quantification of the biological samples. Please see the description of OpenMS and XCMS in quantification section. In brief, if you have selected doing centroiding, you need to change OpenMS PeakPickerHiRes parameter file for the library.\n\nPlease edit the following files (separate for positive and negative):\n\n```bash\n    assets/openms/openms_peak_picker_lib_ini_neg.ini\n```\n\nyou will have to set whether you do the quantification using either OpenMS (set to openms) or XCMS (set to xcms) (**for library**):\n\n```nextflow\n    quantification_openms_xcms_library_neg=\"xcms\"\n```\n\nIf OpenMS selected, please edit the following files for doing mass trace detection for the library:\n\n```bash\n    assets/openms/openms_feature_finder_metabo_lib_ini_neg.ini\n```\n\nIf you have selected to do quantification using XCMS, you need to tune the following parameters (See the corresponding sections in the quantification above):\n\n## Parameters for XCMS and CAMERA (library)\n\nThe same parameters that were set for quantification and adducts identification should be set here for identification. See quantification parameters. \n\nFor example, one can run IPO for setting the parameters for use individual parameters.\n\n## Mapping MS2 to features (within the library)\n\nppm deviation when mapping MS2 parent ion to a mass trace:\n\n```nextflow\n    ppm_mapmsmstocamera_library_neg_msnbase=\"10\"\n```\n\nRT difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace):\n\n```nextflow\n    rt_mapmsmstocamera_library_neg_msnbase=\"5\"\n```\n\n"
        },
        "internal_library_parameters_negative_mode": {
            "title": "Internal library parameters (negative mode)",
            "type": "object",
            "description": "Parameters used to characterize the internal library",
            "default": "",
            "properties": {
                "raw_file_name_preparelibrary_neg_msnbase": {
                    "type": "string",
                    "default": "rawFile",
                    "description": "name of the column showing which raw files contain which metabolite in the library_description_neg csv file"
                },
                "compund_id_preparelibrary_neg_msnbase": {
                    "type": "string",
                    "default": "HMDB.YMDB.ID",
                    "description": "name of the column showing id of the metabolites in the library_description_neg csv file"
                },
                "compound_name_preparelibrary_neg_msnbase": {
                    "type": "string",
                    "default": "PRIMARY_NAME",
                    "description": "name of the compount column in the library_description_neg csv file"
                },
                "mz_col_preparelibrary_neg_msnbase": {
                    "type": "string",
                    "default": "mz",
                    "description": "name of the mz column in the library_description_neg csv file"
                },
                "which_mz_preparelibrary_neg_msnbase": {
                    "type": "string",
                    "default": "f",
                    "description": "\"f\" or \"c\", showing whether the Feature range or centroid of the feature should be used for mapping",
                    "enum": [
                        "f",
                        "c"
                    ]
                },
                "ncore_searchengine_library_neg_msnbase": {
                    "type": "integer",
                    "default": 1,
                    "description": "Number of cores for mapping the features"
                },
                "ppm_create_library_neg_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm error for mapping the library characterization masses to the experimental one"
                }
            },
            "help_text": "Please set the following parameters based on your library description files\n\nColumn name showing name of the raw file in the library file e.g. \"raw.File\" in the table above:\n\n```nextflow\n    raw_file_name_preparelibrary_neg_msnbase=\"\"\n```\n\nColumn name showing ID of the compound in the library file e.g. \"HMDB.ID\" in the table above:\n\n```nextflow\n    compund_id_preparelibrary_neg_msnbase=\"\"\n```\n\nColumn name showing name of the compound in the library file e.g. \"Name\" in the table above:\n\n```nextflow\n    compound_name_preparelibrary_neg_msnbase=\"\"\n```\n\nColumn name showing m/z of the compound in the library file e.g. \"m.z\" in the table above:\n\n```nextflow\n    mz_col_preparelibrary_neg_msnbase=\"mz\"\n```\n\nThe function can use feature range (f), centroid (c), and parent m/z (Parent) information in order to map a compound to MS1 and MS2 information:\n\n```nextflow\n    which_mz_preparelibrary_neg_msnbase=\"f\"\n```\n\nSet the relative mass deviation (ppm) between the experimental and theoretical masses of metabolites:\n\n```nextflow\n    ppm_create_library_neg_msnbase=10\n```\n\nNumber of cores for mapping the features:\n\n```nextflow\n    ncore_searchengine_library_neg_msnbase=1\n```\n\n"
        },
        "output_preparation_negative_mode": {
            "title": "Output preparation (negative mode)",
            "type": "object",
            "description": "Parameters that control how the results are outputted",
            "default": "",
            "properties": {
                "ppm_output_neg_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "relative difference of mass of the ID hit compare to a mass trace (ppm)"
                },
                "rt_output_neg_camera": {
                    "type": "integer",
                    "default": 5,
                    "description": "retention time difference of ID to mass trace (second)"
                },
                "higher_the_better_output_neg_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "is higher the score the better (not used for now)",
                    "hidden": true
                },
                "impute_output_neg_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "should we impute adduct and different chance states with the same ID"
                },
                "type_column_output_neg_camera": {
                    "type": "string",
                    "default": "Class",
                    "description": "Class of the samples (used for statistics and coverage calculations)"
                },
                "selected_type_output_neg_camera": {
                    "type": "string",
                    "default": "Sample",
                    "description": "what class of samples do you want to keep (anything not matching this in the Class column will be removed)"
                },
                "rename_output_neg_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "you want to rename the files"
                },
                "rename_col_output_neg_camera": {
                    "type": "string",
                    "default": "rename",
                    "description": "which column of the phenotype file to use for renaming"
                },
                "only_report_with_id_output_neg_camera": {
                    "type": "boolean",
                    "default": false,
                    "description": "do only want to see the identified mass traces or everything?"
                },
                "combine_replicate_output_neg_camera": {
                    "type": "boolean",
                    "default": false,
                    "description": "do you have technical replicates you want to average ?"
                },
                "combine_replicate_column_output_neg_camera": {
                    "type": "string",
                    "default": "rep",
                    "description": "which column of the phenotype file show the technical replicates"
                },
                "log_output_neg_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "should we log2 the output"
                },
                "sample_coverage_output_neg_camera": {
                    "type": "integer",
                    "default": 50,
                    "description": "any mass trace having more pecentage of the missing value will be removed"
                },
                "sample_coverage_method_output_neg_camera": {
                    "type": "string",
                    "default": "global",
                    "description": "how to calculate missing value percentrage? global across all the samples? or name of the column in the phenotype file showing the grouping"
                },
                "ncore_output_neg_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of cores used for mapping the features"
                },
                "normalize_output_neg_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "do you want to normalize the data set to 'NA' if you don't want normalization"
                }
            },
            "help_text": "Each process in the workflow will create a folder with the following pattern:\n(output directory)/process_(name of the process)_(if it is the library or not)_(ionization mode)_(name of the process)\n\nThe most import outputs are the results of process_output that contains three tabular files, one for the peak table, one for the variable information (including identification etc) and metadata information.\n"
        },
        "cfm_id_parameters_negative_mode": {
            "title": "CFM-ID parameters (negative mode)",
            "type": "object",
            "description": "Parameters specific to CFM-ID",
            "default": "",
            "properties": {
                "database_csv_files_neg_cfmid": {
                    "type": "string",
                    "description": "path to a csv file containing your database"
                },
                "ncore_neg_cfmid": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that cfm can use"
                },
                "candidate_id_identification_neg_cfmid": {
                    "type": "string",
                    "default": "Identifier",
                    "description": "name of the column in the database for id of the molecules"
                },
                "candidate_inchi_smiles_identification_neg_cfmid": {
                    "type": "string",
                    "default": "SMILES",
                    "description": "name of the column in the database for smile of the molecules"
                },
                "candidate_mass_identification_neg_cfmid": {
                    "type": "string",
                    "default": "MonoisotopicMass",
                    "description": "name of the column in the database for mass of the molecules"
                },
                "database_name_column_identification_neg_cfmid": {
                    "type": "string",
                    "default": "Name",
                    "description": "name of the column in the database for name of the molecules"
                },
                "database_inchI_column_identification_neg_cfmid": {
                    "type": "string",
                    "default": "InChI",
                    "description": "name of the column in the database for inchi of the molecules"
                }
            },
            "help_text": "You need to specify the database for CFM-ID. The rest of the parameters will be taken from the global parameters. Please see MetFrag parameter on how to construct the database.\nThis database must at least contain the following columns: id of the molecules, smile of the molecules, the mass of the molecules, name of the molecules and InChI of the molecules. The best practice would be to use [MetChem](https://github.com/c-ruttkies/container-metchemdata) to construct the database.\n\nAbsolute path to a csv file containing your database:\n\n```nextflow\n    database_csv_files_neg_cfmid=\"\"\n```\n\nName of the column in the database file for id of the molecules:\n\n```nextflow\n    candidate_id_identification_neg_cfmid=\"Identifier\"\n```\n\nName of the column in the database file for smile of the molecules:\n\n```nextflow\n    candidate_inchi_smiles_identification_neg_cfmid=\"SMILES\"\n```\n\nName of the column in the database file for mass of the molecules:\n\n```nextflow\n    candidate_mass_identification_neg_cfmid=\"MonoisotopicMass\"\n```\n\nName of the column in the database file for name of the molecules:\n\n```nextflow\n    database_name_column_identification_neg_cfmid=\"Name\"\n```\n\nName of the column in the database file for InChI of the molecules:\n\n```nextflow\n    database_inchI_column_identification_neg_cfmid=\"InChI\"\n```\n\nNumber of cores for CFM-ID:\n\n```nextflow\n    ncore_neg_cfmid=2\n```\n"
        },
        "metfrag_parameters_negative_mode": {
            "title": "MetFrag parameters (negative mode)",
            "type": "object",
            "description": "Parameters only for MetFrag",
            "default": "",
            "properties": {
                "database_csv_files_neg_metfrag": {
                    "type": "string",
                    "description": "path to a csv file containing your database"
                },
                "ncore_neg_metfrag": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that metfrag can use"
                }
            },
            "help_text": "We only need two parameters if the global parameters have been set properly. This is the database file. An example of such a database can be found [here](https://raw.githubusercontent.com/nf-core/test-datasets/metaboigniter/hmdb_2017-07-23.csv). You can either use the example for HMDB (2017) or generate your own using [MetChem](https://github.com/c-ruttkies/container-metchemdata). Please contact us if you need to generate this file.\n\nAbsolute path to the generated database file:\n\n```nextflow\n    database_csv_files_neg_metfrag=\"\"\n```\n\nNumber of cores used for Metfrag:\n\n```nextflow\n    ncore_neg_metfrag=2\n```"
        },
        "csi_fingerid_parameters_negative_mode": {
            "title": "CSI:FINGERID parameters (negative mode)",
            "type": "object",
            "description": "Parameters only for CSI:FINGERID",
            "default": "",
            "properties": {
                "database_csifingerid_neg_csifingerid": {
                    "type": "string",
                    "default": "hmdb",
                    "description": "IMPORTANT: we don't support database file for csi:fingerid. You will need to provide what database to use here, the rest of the parameters will be taken from there parameter file"
                },
                "ncore_csifingerid_neg_csifingerid": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that csi can use"
                },
                "timeout_csifingerid_neg_csifingerid": {
                    "type": "integer",
                    "default": 600,
                    "description": "number of seconds that each csi ion can rum (time limit)"
                }
            },
            "help_text": "Please select the database to be used for CSIFingerID. **IMPORTANT: we don't support database file for csi:fingerid. You will need to provide what database to use here, the rest of the parameters will be taken from there parameter file**\n\nDatabase (this will overwrite the corresponding parameter in the input file). CSI:FingerID does not have LocalCSV. So if you set this in the previous step, change this to your desired database (**one of**: all, chebi, kegg, bio, natural products, pubmed, hmdb, biocyc, hsdb, knapsack, biological, zinc bio, gnps, pubchem, mesh, maconda):\n\n```nextflow\n    database_csifingerid_neg_csifingerid=\"hmdb\"\n```\n\nNumber of cores used for CSI:\n\n```nextflow\n    ncore_csifingerid_neg_csifingerid=2\n```\n\nNumber of seconds that each csi ion can rum (time limit)\n\n```nextflow\n    timeout_csifingerid_neg_csifingerid=600\n```"
        },
        "global_identification_parameters_negative_mode": {
            "title": "Global identification parameters (negative mode)",
            "type": "object",
            "description": "Parameters that will be used in all the search engines",
            "default": "",
            "properties": {
                "ppm_mapmsmstocamera_neg_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation when mapping MS2 parent ion to a mass trace"
                },
                "rt_mapmsmstocamera_neg_msnbase": {
                    "type": "integer",
                    "default": 5,
                    "description": "rt difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace)"
                },
                "precursorppm_msmstoparam_neg_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "relative mass tolerance of the precursor (ppm)"
                },
                "fragmentppm_msmstoparam_neg_msnbase": {
                    "type": "integer",
                    "default": 20,
                    "description": "relative mass tolerance of the fragment ions (ppm)"
                },
                "fragmentabs_msmstoparam_neg_msnbase": {
                    "type": "number",
                    "default": 0.05,
                    "description": "absolute mass tolerance of the fragment ions"
                },
                "database_msmstoparam_neg_msnbase": {
                    "type": "string",
                    "default": "LocalCSV",
                    "description": "type of database to use (see metaboIGNITER guide)"
                },
                "mode_msmstoparam_neg_msnbase": {
                    "type": "string",
                    "default": "neg",
                    "description": "ionization method. This has to be neg (only for testing at this stage)",
                    "hidden": true
                },
                "adductRules_msmstoparam_neg_msnbase": {
                    "type": "string",
                    "default": "primary",
                    "description": "adduct rules (primary or extended)",
                    "enum": [
                        "primary",
                        "extended"
                    ]
                },
                "minPeaks_msmstoparam_neg_msnbase": {
                    "type": "integer",
                    "default": 2,
                    "description": "ions with less that this number will be removed"
                }
            },
            "help_text": "This module is used to map MS/MS spectra to annotated CAMERA features. The mapping is performed based on retention time and m/z values of the annotated features.\n\nThe ppm error used for the mapping:\n\n```nextflow\n    ppm_mapmsmstocamera_neg_msnbase=\"10\"\n```\n\nThe retention time error (in seconds) used for the mapping:\n\n```nextflow\n    rt_mapmsmstocamera_neg_msnbase=\"5\"\n```\n\n## global parameters (Producing search files)\n\nThis module is used to generate search parameters with mapped MS/MS spectra retrieved from the mzML files. These parameters will be sent to all the search engines. You will then have the possibility to set the search engine specific parameters. The only exception is *database_msmstoparam_neg/neg_msnbase* that is only applicable in **MetFrag**.\n\nThe ppm error for the precursor mass to search candidates:\n\n```nextflow\n    precursorppm_msmstoparam_neg_msnbase=\"10\"\n```\n\nThe ppm error to assign fragments to fragment peaks:\n\n```nextflow\n    fragmentppm_msmstoparam_neg_msnbase=\"20\"\n```\n\nAbsolute mass error to assign fragments to fragment peaks:\n\n```nextflow\n    fragmentabs_msmstoparam_neg_msnbase=\"0.05\"\n```\n\nAvailable databases are KEGG, PubChem, MetChem (a local database that needs to be set up beforehand). In addition, LocalCSV can be used which uses a CSV file for searching. Such a CSV file can be downloaded from [here](https://msbi.ipb-halle.de/~cruttkie/databases/).\nIf LocalCSV is selected, a specific file needs to be provided. The format of this file is very strict. See the database parameter.\n\n```nextflow\n    database_msmstoparam_neg_msnbase=\"LocalCSV\"\n```\n\nAdduct ruleset to be used:\nprimary - contains most common adduct types ([M-H]-, [M-2H+Na]-, [M-2H+K]-, [M+Cl]-, [M+H]+, [M+Na]+, [M+K]+, [M+NH4]+)\nextended - next to primary also additional adduct types\n\n```nextflow\n    adductRules_msmstoparam_neg_msnbase=\"primary\"\n```\n\nFilter spectra by a minimum number of fragment peaks:\n\n```nextflow\n    minPeaks_msmstoparam_neg_msnbase=\"2\"\n```\n"
        },
        "adduct_and_isotope_annotation_negative_mode": {
            "title": "Adduct and isotope annotation (negative mode)",
            "type": "object",
            "description": "Settings for CAMERA to detect adducts and isotopes",
            "default": "",
            "properties": {
                "sigma_group_neg_camera": {
                    "type": "integer",
                    "default": 8,
                    "description": "sigma value for grouping the peaks across chromatogram"
                },
                "perfwhm_group_neg_camera": {
                    "type": "number",
                    "default": 0.6,
                    "description": "full width at half maximum for finding overlaping peaks"
                },
                "intval_group_neg_camera": {
                    "type": "string",
                    "default": "maxo",
                    "description": "which intensity value to use"
                },
                "ppm_findaddcuts_neg_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation between theoritical adduct mass and the experimental one"
                },
                "polarity_findaddcuts_neg_camera": {
                    "type": "string",
                    "default": "negative",
                    "description": "this has to be negative (for testing only)!",
                    "hidden": true
                },
                "maxcharge_findisotopes_neg_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of changes to consider (most often 1 is enough)"
                }
            },
            "help_text": "MetaboIGNITER performs annotation using CAMERA package in R. We first do FWHM grouping, then perform adduct detection followed by isotope finding. The specific details of this can be found on [CAMERA webpage](http://bioconductor.org/packages/release/bioc/html/CAMERA.html).\n\n## CAMERA Group FWHM\n\nGroup peaks of a xsAnnotate object according to there retention time into pseudospectral-groups. Uses the peak FWHMs as grouping borders. Returns xsAnnotate object with pseudospectral information.\nThe multiplier of the standard deviation:\n\n```nextflow\n    sigma_group_neg_camera=\"8\"\n```\n\nPercentage of the width of the FWHM:\n\n```nextflow\n    perfwhm_group_neg_camera=\"0.6\"\n```\n\nIntensity values for ordering. Allowed values are into, maxo, intb\"\n\n```nextflow\n    intval_group_neg_camera=\"maxo\"\n```\n\n## CAMERA Find Adducts\n\nAnnotate adducts (and fragments) for a xsAnnotate object. Returns a xsAnnotate object with annotated pseudospectra:\n\nThe ppm error for the search:\n\n```nextflow\n    ppm_findaddcuts_neg_camera=\"10\"\n```\n\n## CAMERA Find Isotopes\n\nAnnotate isotope peaks for a xsAnnotate object. Returns a xsAnnotate object with annotated isotopes.\n\nMax. number of the isotope charge:\n\n```nextflow\n    maxcharge_findisotopes_neg_camera=1\n```\n"
        },
        "filtering_parameters_negative_mode": {
            "title": "Filtering parameters (negative mode)",
            "type": "object",
            "description": "Parameters to use for performing QC, blank and dilution filtering",
            "default": "",
            "properties": {
                "blank_filter_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "set to true if you want to remove signal from blank"
                },
                "method_blankfilter_neg_xcms": {
                    "type": "string",
                    "default": "max",
                    "description": "method of sumarization of signal in blank samples"
                },
                "blank_blankfilter_neg_xcms": {
                    "type": "string",
                    "default": "Blank",
                    "description": "Name of the class of the blank samples"
                },
                "sample_blankfilter_neg_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "Name of the class of the biological samples"
                },
                "rest_blankfilter_neg_xcms": {
                    "type": "string",
                    "default": "T",
                    "description": "set to T to compare blanks only to rest of the samples",
                    "enum": [
                        "T",
                        "F"
                    ]
                },
                "dilution_filter_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether blank filtereing should be done or not?"
                },
                "corto_dilutionfilter_neg_xcms": {
                    "type": "string",
                    "default": "0.5,1,2,4",
                    "description": "The class of the samples represneting dilution. This has to be separated by comma!"
                },
                "dilution_dilutionfilter_neg_xcms": {
                    "type": "string",
                    "default": "D1,D2,D3,D4",
                    "description": "The class of the samples represneting dilution. This has to be separated by comma!"
                },
                "pvalue_dilutionfilter_neg_xcms": {
                    "type": "number",
                    "default": 0.05,
                    "description": "p-value of the correlation. Anything higher than this will be removed!"
                },
                "corcut_dilutionfilter_neg_xcms": {
                    "type": "integer",
                    "default": -1,
                    "description": "minimum expected correlation. Aniything lower than this will be removed!"
                },
                "abs_dilutionfilter_neg_xcms": {
                    "type": "string",
                    "default": "F",
                    "description": "If the tool should consider absolute correlation rather than the typical one from [-1 to 1] (F or T)",
                    "enum": [
                        "T",
                        "F"
                    ]
                },
                "cv_filter_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "select to whether perfrom cv filtering or not"
                },
                "qc_cvfilter_neg_xcms": {
                    "type": "string",
                    "default": "QC",
                    "description": "class of your QC samples"
                },
                "cvcut_cvfilter_neg_xcms": {
                    "type": "number",
                    "default": 0.3,
                    "description": "Maximum coefficient of variation you expect. Anything higher than this will be removed!"
                }
            },
            "help_text": "## Signal filtering\n\nAs described above, currently we support three types of signal filtering. You can turn them on and off depending on the availability of the data, experimental design or if you wish to do the manually later.\n\n## Blank filtering\n\nThe first method is *blank filtering*. This module filters out the signals that have higher abundance in non-biological samples (e.g. blank) compared to biological samples.\n\nIf you don't want to perform the blank filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\n    blank_filter_neg\n```\n\nWhich method to use for summarizing blank and biological sample for comparisons. For example, if Max is selected, a signal will be removed if it maximum abundance in the blank samples is higher than maximum abundance in biological samples (one of max, mean, median):\n\n```nextflow\n    method_blankfilter_neg_xcms=\"max\"\n```\n\nThis must indicate the class of blank samples exactly as you refer to them in your phenotype file. IMPORTANT: This class should be identical for all the blank samples:\n\n```nextflow\n    blank_blankfilter_neg_xcms\n```\n\nIf true, the (average, median, max) abundance of blank samples will be compared against all other samples. For false see the next parameter:\n\n```nextflow\n    rest_blankfilter_neg_xcms=\"true\"\n```\n\nIf the previous parameter is false, a sample class can be specified so that blank abundance will be compared against this sample class:\n\n```nextflow\n    sample_blankfilter_neg_xcms\n```\n\n## Dilution filtering\n\nThis module filters out the signals that do not correlate with a specified dilution trend.\nIf you don't want to perform the dilution filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\n    dilution_filter_neg\n```\n\nThis series will used for calculation of correlation. For example if this parameter is set like 1,2,3 and the class of dilution trends is set as D1,D2,D3 the following the pairs will be used for calculating the correlation: (D1,1),(D2,2),(D3,3):\n\n```nextflow\n    corto_dilutionfilter_neg_xcms=\"0.5,1,2,4\"\n```\n\nThis must indicate the class of dilution trend samples. IMPORTANT: the samples are correlated to the exact order of the sequence as set here:\n\n```nextflow\n    dilution_dilutionfilter_neg_xcms=\"D1,D2,D3,D4\"\n```\n\nSignals with correlation p-value higher than this will be removed:\n\n```nextflow\n    pvalue_dilutionfilter_neg_xcms=\"0.05\"\n```\n\nSignals with lower correlation than this will be removed:\n\n```nextflow\n    corcut_dilutionfilter_neg_xcms=\"-1\"\n```\n\nShould the algorithm use the correlation as it is (negative and positive) or absolute correlation (either true or false):\n\n```nextflow\n    abs_dilutionfilter_neg_xcms=\"false\"\n```\n\n## CV filtering\n\nThis module filters out the signals that do not show the desired coefficient of variation.\nIf you don't want to perform the CV filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\ncv_filter_neg\n```\n\nThis must indicate the class of QC samples:\n\n```nextflow\n    qc_cvfilter_neg_xcms=\"QC\"\n```\n\nSignals with CVs higher than this will be removed:\n\n```nextflow\n    cvcut_cvfilter_neg_xcms=0.3\n```"
        },
        "quantification_parameter_negative_mode": {
            "title": "Quantification parameter (negative mode)",
            "type": "object",
            "description": "Parameters for quantification",
            "default": "",
            "properties": {
                "quantification_openms_xcms_neg": {
                    "type": "string",
                    "default": "xcms",
                    "description": "set whether you want to do quantification with OpenMS (openms) or XCMS (xcms) in negative ionization",
                    "enum": [
                        "xcms",
                        "openms"
                    ]
                },
                "performIPO_neg": {
                    "type": "string",
                    "default": "none",
                    "description": "controls how to perform IPO possible values: \"none\": don't perform IPO, \"global\": performs IPO on all or selected number of samples. \"global_quant\": perform IPO only for quantification (not retention time correction and grouping), \"local\": performs IPO on individual samples one at the time. \"local_quant\": performs IPO on individual samples only for quantification, \"local_RT\": performs IPO on only for retention time correction and grouping.",
                    "enum": [
                        "none",
                        "global",
                        "global_quant",
                        "local",
                        "local_quant",
                        "local_RT"
                    ]
                },
                "ipo_allSamples_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "Performs IPO on all the samples irrespective of the class they have"
                },
                "ipo_columnToSelect_neg": {
                    "type": "string",
                    "default": "Class",
                    "description": "If ipo_allSamples_neg is false, one must pass the phenotype file to select sample. This parameter select the column of the phenotype file."
                },
                "ipo_valueToSelect_neg": {
                    "type": "string",
                    "default": "QC",
                    "description": "Selects the files only with this value in the columnToSelect column"
                },
                "ipo_methodXset_neg": {
                    "type": "string",
                    "default": "centWave",
                    "description": "Quantification methods for IPO. Only centWave is supported at this stage."
                },
                "ipo_noise_l_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "lowest level of noise"
                },
                "ipo_noise_h_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "highest level of noise"
                },
                "ipo_snthresh_l_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "lowest level of signal to noise threshold"
                },
                "ipo_snthresh_h_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "highest level of signal to noise threshold"
                },
                "ipo_mzCenterFun_neg": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function for centering the mz"
                },
                "ipo_integrate_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "ipo_fitgauss_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitte"
                },
                "ipo_min_peakwidth_l_neg": {
                    "type": "integer",
                    "default": 12,
                    "description": "lower minimum width of peaks"
                },
                "ipo_min_peakwidth_h_neg": {
                    "type": "integer",
                    "default": 28,
                    "description": "higher minimum width of peaks"
                },
                "ipo_max_peakwidth_l_neg": {
                    "type": "integer",
                    "default": 35,
                    "description": "lower maximum width of peaks"
                },
                "ipo_max_peakwidth_h_neg": {
                    "type": "integer",
                    "default": 65,
                    "description": "higher maximum width of peaks"
                },
                "ipo_ppm_l_neg": {
                    "type": "integer",
                    "default": 17,
                    "description": "lower ppm mass deviation"
                },
                "ipo_ppm_h_neg": {
                    "type": "integer",
                    "default": 32,
                    "description": "higher ppm mass deviation"
                },
                "ipo_mzdiff_l_neg": {
                    "type": "number",
                    "default": -0.001,
                    "description": "lower minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_mzdiff_h_neg": {
                    "type": "number",
                    "default": 0.01,
                    "description": "higher minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_charge_camera_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "maximum charge of molecules (only used in individual setting)"
                },
                "ipo_max_ppm_camera_neg": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm mass deviation for adducts (only used in individual setting)"
                },
                "ipo_prefilter_l_l_neg": {
                    "type": "integer",
                    "default": 3,
                    "description": "lower value of K in 'prefilter_neg=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_neg= 'I'."
                },
                "ipo_prefilter_l_h_neg": {
                    "type": "integer",
                    "default": 3,
                    "description": "higher value of K in 'prefilter_neg=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_neg= 'I'."
                },
                "ipo_prefilter_h_l_neg": {
                    "type": "integer",
                    "default": 100,
                    "description": "lower I in prefilter"
                },
                "ipo_prefilter_h_h_neg": {
                    "type": "integer",
                    "default": 100,
                    "description": "higher I in prefilter"
                },
                "ipo_ncores_neg": {
                    "type": "integer",
                    "default": 5,
                    "description": "number of cores used in IPO"
                },
                "ipo_gapInit_l_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "lower Penalty for Gap opening"
                },
                "ipo_gapInit_h_neg": {
                    "type": "number",
                    "default": 0.4,
                    "description": "higher Penalty for Gap opening"
                },
                "ipo_gapExtend_l_neg": {
                    "type": "number",
                    "default": 2.1,
                    "description": "lower Penalty for Gap enlargement"
                },
                "ipo_gapExtend_h_neg": {
                    "type": "number",
                    "default": 2.7,
                    "description": "higher Penalty for Gap enlargement"
                },
                "ipo_profStep_l_neg": {
                    "type": "number",
                    "default": 0.7,
                    "description": "lower step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_profStep_h_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_response_l_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_response_h_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_factorDiag_l_neg": {
                    "type": "integer",
                    "default": 2,
                    "description": "lower Local weighting applied to diagonal moves in alignment"
                },
                "ipo_factorDiag_h_neg": {
                    "type": "integer",
                    "default": 2,
                    "description": "higher Local weighting applied to diagonal moves in alignment"
                },
                "ipo_factorGap_l_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Local weighting applied to gap moves in alignment"
                },
                "ipo_factorGap_h_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Local weighting applied to gap moves in alignment"
                },
                "ipo_localAlignment_neg": {
                    "type": "integer",
                    "default": 0,
                    "description": "Local rather than global alignment"
                },
                "ipo_bw_l_neg": {
                    "type": "integer",
                    "default": 22,
                    "description": "lower bandwidth (consider something like retention time differences)"
                },
                "ipo_bw_h_neg": {
                    "type": "integer",
                    "default": 38,
                    "description": "higher bandwidth (consider something like retention time differences)"
                },
                "ipo_minfrac_l_neg": {
                    "type": "number",
                    "default": 0.3,
                    "description": "lower minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minfrac_h_neg": {
                    "type": "number",
                    "default": 0.7,
                    "description": "higher minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_mzwid_l_neg": {
                    "type": "number",
                    "default": 0.015,
                    "description": "lower mz width (mz differences)"
                },
                "ipo_mzwid_h_neg": {
                    "type": "number",
                    "default": 0.035,
                    "description": "higher mz width (mz differences)"
                },
                "ipo_minsamp_l_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minsamp_h_neg": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_max_l_neg": {
                    "type": "integer",
                    "default": 50,
                    "description": "lower maximum number of groups to identify in a single m/z slice"
                },
                "ipo_max_h_neg": {
                    "type": "integer",
                    "default": 50,
                    "description": "higher maximum number of groups to identify in a single m/z slice"
                },
                "ipo_distFunc_neg": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)"
                },
                "ipo_methodRT_neg": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "Only obiwarp is supported"
                },
                "masstrace_ppm_neg_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "masstrance deviation in ppm"
                },
                "peakwidthlow_quant_neg_xcms": {
                    "type": "integer",
                    "default": 5,
                    "description": "lower width of peaks"
                },
                "peakwidthhigh_quant_neg_xcms": {
                    "type": "integer",
                    "default": 30,
                    "description": "highest width of peaks"
                },
                "noise_quant_neg_xcms": {
                    "type": "integer",
                    "default": 1000,
                    "description": "level of noise"
                },
                "mzdiff_quant_neg_xcms": {
                    "type": "number",
                    "default": -0.001,
                    "description": "minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "snthresh_quant_neg_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "signal to noise ratio cutoff, definition see below."
                },
                "prefilter_quant_neg_xcms": {
                    "type": "integer",
                    "default": 3,
                    "description": "K in 'prefilter=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >= 'I'."
                },
                "value_of_prefilter_quant_neg_xcms": {
                    "type": "integer",
                    "default": 100,
                    "description": "I in prefilter"
                },
                "mzCenterFun_quant_neg_xcms": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function to calculate the m/z center of the feature: 'wMean' intensity weighted mean of the feature m/z values, 'mean' mean of the feature m/z values, 'apex' use m/z value at peak apex, 'wMeanApex3' intensity weighted mean of the m/z value at peak apex and the m/z value left and right of it, 'meanApex3' mean of the m/z value at peak apex and the m/z value left and right of it."
                },
                "integrate_quant_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "fitgauss_quant_neg_xcms": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitted"
                },
                "phenodatacolumn_quant_neg": {
                    "type": "string",
                    "default": "Class",
                    "description": "name of the column in the phenotype_design_neg showing class information of the samples"
                },
                "sampleclass_quant_neg_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "A name for the class of sample"
                },
                "method_align_N1_neg_xcms": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "name of the method for correcting the RT shifts."
                },
                "profStep_align_N1_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "step size (in m/z) to use for profile generation from the raw data files"
                },
                "center_align_N1_neg_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "the index of the sample all others will be aligned to. If center==NULL, the sample with the most peaks is chosen as default."
                },
                "response_align_N1_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "distFunc_align_N1_neg_xcms": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)",
                    "enum": [
                        "cor",
                        "cor_opt",
                        "cov",
                        "prd",
                        "euc"
                    ]
                },
                "gapInit_align_N1_neg_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "Penalty for Gap opening"
                },
                "gapExtend_align_N1_neg_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "Penalty for Gap enlargement"
                },
                "factorDiag_align_N1_neg_xcms": {
                    "type": "integer",
                    "default": 2,
                    "description": "Local weighting applied to diagonal moves in alignment"
                },
                "factorGap_align_N1_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Local weighting applied to gap moves in alignment"
                },
                "localAlignment_align_N1_neg_xcms": {
                    "type": "integer",
                    "description": "Local rather than global alignment"
                },
                "bandwidth_group_N1_neg_xcms": {
                    "type": "integer",
                    "default": 15,
                    "description": "bandwidth (consider something like retention time differences)"
                },
                "mzwid_group_N1_neg_xcms": {
                    "type": "number",
                    "default": 0.005,
                    "description": "mz width (mz differences)"
                },
                "minfrac_group_N1_neg_xcms": {
                    "type": "number",
                    "default": 0.5,
                    "description": "minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "minsamp_group_N1_neg_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "max_group_N1_neg_xcms": {
                    "type": "integer",
                    "default": 50,
                    "description": "maximum number of groups to identify in a single m/z slice"
                }
            },
            "help_text": "## Automatic parameter selection\n\nMetaboIGNITER supports parameter detection using IPO. MetaboIGNITER can run IPO on pos, neg and library separately. Here we demonstrate the usage of the positive ionization method.\nThe same principles apply to negative and library mode. If you decided to go with a full IPO, you won't need to set other parameters.\nIn order to turn this parameter on, one should use:\n\n```nextflow\n    performIPO_pos=\"none\"\n```\n\nThe default parameter sets IPO to off, you can control how to perform IPO using possible values: \"none\": don't perform IPO, \"global\": performs IPO on all or selected number of samples. \"global_quant\": perform IPO only for quantification (not retention time correction and grouping), \"local\": performs IPO on individual samples one at the time. \"local_quant\": performs IPO on individual samples only for quantification, \"local_RT\": performs IPO only for retention time correction and grouping.\n\nThere are several parameters that need to be set for IPO to optimize. If you don't want to optimize a parameter, set its higher and lower boundaries to the same value. The parameters for IPO starts with \"ipo_\"\n\n## XCMS\n\nThis is the default behaviour of the workflow. You need to set the following parameters that end in \"xcms\"\n\nIn addition, the following should show the column name in the CSV file representing the class of the metabolite. In the case of the above phenotype table it should be set to Class:\n\n```nextflow\n    phenodatacolumn_quant_pos=\"Class\"\n```\n"
        },
        "internal_library_quantification_and_identification_parameters_positive_mode": {
            "title": "Internal library quantification and identification parameters (positive mode)",
            "type": "object",
            "description": "Parameters used to tune library creation (only set if you want to do library idnetification)",
            "default": "",
            "properties": {
                "quantification_openms_xcms_library_pos": {
                    "type": "string",
                    "default": "xcms",
                    "description": "set whether you want to do quantification with OpenMS (openms) or XCMS (xcms) in positive ionization  (for library)",
                    "enum": [
                        "xcms",
                        "openms"
                    ]
                },
                "performIPO_library_pos": {
                    "type": "string",
                    "default": "none",
                    "description": "controls how to perform IPO possible values: \"none\": don't perform IPO, \"global\": performs IPO on all or selected number of samples. \"local\": performs IPO on individual samples one at the time.",
                    "enum": [
                        "none",
                        "global",
                        "local"
                    ]
                },
                "ipo_methodXset_library_pos": {
                    "type": "string",
                    "default": "centWave",
                    "description": "Quantification methods for IPO. Only centWave is supported at this stage."
                },
                "ipo_noise_l_library_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "lowest level of noise"
                },
                "ipo_noise_h_library_pos": {
                    "type": "integer",
                    "description": "highest level of noise"
                },
                "ipo_snthresh_l_library_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "lowest level of signal to noise threshold"
                },
                "ipo_snthresh_h_library_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "highest level of signal to noise threshold"
                },
                "ipo_mzCenterFun_library_pos": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function for centering the mz"
                },
                "ipo_integrate_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "ipo_fitgauss_library_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitte"
                },
                "ipo_min_peakwidth_l_library_pos": {
                    "type": "integer",
                    "default": 12,
                    "description": "lower minimum width of peaks"
                },
                "ipo_min_peakwidth_h_library_pos": {
                    "type": "integer",
                    "default": 28,
                    "description": "higher minimum width of peaks"
                },
                "ipo_max_peakwidth_l_library_pos": {
                    "type": "integer",
                    "default": 35,
                    "description": "lower maximum width of peaks"
                },
                "ipo_max_peakwidth_h_library_pos": {
                    "type": "integer",
                    "default": 65,
                    "description": "higher maximum width of peaks"
                },
                "ipo_ppm_l_library_pos": {
                    "type": "integer",
                    "default": 17,
                    "description": "lower ppm mass deviation"
                },
                "ipo_ppm_h_library_pos": {
                    "type": "integer",
                    "default": 32,
                    "description": "higher ppm mass deviation"
                },
                "ipo_mzdiff_l_library_pos": {
                    "type": "number",
                    "default": -0.001,
                    "description": "lower minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_mzdiff_h_library_pos": {
                    "type": "number",
                    "default": 0.01,
                    "description": "higher minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_charge_camera_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "maximum charge of molecules (only used in individual setting)"
                },
                "ipo_max_ppm_camera_library_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm mass deviation for adducts (only used in individual setting)"
                },
                "ipo_prefilter_l_l_library_pos": {
                    "type": "integer",
                    "default": 3,
                    "description": "lower value of K in 'prefilter_library_pos=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_library_pos= 'I'."
                },
                "ipo_prefilter_l_h_library_pos": {
                    "type": "integer",
                    "default": 3,
                    "description": "higher value of K in 'prefilter_library_pos=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_library_pos= 'I'."
                },
                "ipo_prefilter_h_l_library_pos": {
                    "type": "integer",
                    "default": 100,
                    "description": "lower I in prefilter"
                },
                "ipo_prefilter_h_h_library_pos": {
                    "type": "integer",
                    "default": 100,
                    "description": "higher I in prefilter"
                },
                "ipo_ncores_library_pos": {
                    "type": "integer",
                    "default": 5,
                    "description": "number of cores used in IPO"
                },
                "ipo_gapInit_l_library_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "lower Penalty for Gap opening"
                },
                "ipo_gapInit_h_library_pos": {
                    "type": "number",
                    "default": 0.4,
                    "description": "higher Penalty for Gap opening"
                },
                "ipo_gapExtend_l_library_pos": {
                    "type": "number",
                    "default": 2.1,
                    "description": "lower Penalty for Gap enlargement"
                },
                "ipo_gapExtend_h_library_pos": {
                    "type": "number",
                    "default": 2.7,
                    "description": "higher Penalty for Gap enlargement"
                },
                "ipo_profStep_l_library_pos": {
                    "type": "number",
                    "default": 0.7,
                    "description": "lower step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_profStep_h_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_response_l_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_response_h_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_factorDiag_l_library_pos": {
                    "type": "integer",
                    "default": 2,
                    "description": "lower Local weighting applied to diagonal moves in alignment."
                },
                "ipo_factorDiag_h_library_pos": {
                    "type": "integer",
                    "default": 2,
                    "description": "higher Local weighting applied to diagonal moves in alignment."
                },
                "ipo_factorGap_l_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Local weighting applied to gap moves in alignment."
                },
                "ipo_factorGap_h_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Local weighting applied to gap moves in alignment."
                },
                "ipo_localAlignment_library_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "Local rather than global alignment"
                },
                "ipo_bw_l_library_pos": {
                    "type": "integer",
                    "default": 22,
                    "description": "lower bandwidth (consider something like retention time differences)"
                },
                "ipo_bw_h_library_pos": {
                    "type": "integer",
                    "default": 38,
                    "description": "higher bandwidth (consider something like retention time differences)"
                },
                "ipo_minfrac_l_library_pos": {
                    "type": "number",
                    "default": 0.3,
                    "description": "lower minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minfrac_h_library_pos": {
                    "type": "number",
                    "default": 0.7,
                    "description": "higher minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_mzwid_l_library_pos": {
                    "type": "number",
                    "default": 0.015,
                    "description": "lower mz width (mz differences)"
                },
                "ipo_mzwid_h_library_pos": {
                    "type": "number",
                    "default": 0.035,
                    "description": "higher mz width (mz differences)"
                },
                "ipo_minsamp_l_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minsamp_h_library_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_max_l_library_pos": {
                    "type": "integer",
                    "default": 50,
                    "description": "lower maximum number of groups to identify in a single m/z slice"
                },
                "ipo_max_h_library_pos": {
                    "type": "integer",
                    "default": 50,
                    "description": "higher maximum number of groups to identify in a single m/z slice"
                },
                "ipo_distFunc_library_pos": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)",
                    "enum": [
                        "cor",
                        "cor_opt",
                        "cov",
                        "prd",
                        "euc"
                    ]
                },
                "ipo_methodRT_library_pos": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "Only obiwarp is supported"
                },
                "masstrace_ppm_library_pos_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "mass trace deviation in ppm"
                },
                "peakwidthlow_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 5,
                    "description": "lower width of peaks"
                },
                "peakwidthhigh_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 30,
                    "description": "highest width of peaks"
                },
                "noise_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 1000,
                    "description": "level of noise"
                },
                "mzdiff_quant_library_pos_xcms": {
                    "type": "number",
                    "default": -0.001,
                    "description": "minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "snthresh_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "signal to noise ratio cutoff, definition see below."
                },
                "prefilter_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 3,
                    "description": "K in 'prefilter=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >= 'I'."
                },
                "value_of_prefilter_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 100,
                    "description": "I in prefilter"
                },
                "mzCenterFun_quant_library_pos_xcms": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function to calculate the m/z center of the feature: 'wMean' intensity weighted mean of the feature m/z values, 'mean' mean of the feature m/z values, 'apex' use m/z value at peak apex, 'wMeanApex3' intensity weighted mean of the m/z value at peak apex and the m/z value left and right of it, 'meanApex3' mean of the m/z value at peak apex and the m/z value left and right of it."
                },
                "integrate_quant_library_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "fitgauss_quant_library_pos_xcms": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitted"
                },
                "phenodatacolumn_quant_library_pos": {
                    "type": "string",
                    "default": "Class",
                    "description": "name of the column in the phenotype_design_library_pos showing class information of the samples"
                },
                "sampleclass_quant_library_pos_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "A name for the class of sample"
                },
                "sigma_group_library_pos_camera": {
                    "type": "integer",
                    "default": 8,
                    "description": "sigma value for grouping the peaks across chromatogram"
                },
                "perfwhm_group_library_pos_camera": {
                    "type": "number",
                    "default": 0.6,
                    "description": "full width at half maximum for finding overlaping peaks"
                },
                "intval_group_library_pos_camera": {
                    "type": "string",
                    "default": "maxo",
                    "description": "which intensity value to use"
                },
                "ppm_findaddcuts_library_pos_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation between theoritical adduct mass and the experimental one"
                },
                "polarity_findaddcuts_library_pos_camera": {
                    "type": "string",
                    "default": "positive",
                    "description": "this has to be positive (for testing only)!",
                    "hidden": true
                },
                "maxcharge_findisotopes_library_pos_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of changes to consider (most often 1 is enough)"
                },
                "ppm_mapmsmstocamera_library_pos_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation when mapping MS2 parent ion to a mass trace"
                },
                "rt_mapmsmstocamera_library_pos_msnbase": {
                    "type": "integer",
                    "default": 5,
                    "description": "rt difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace)"
                }
            },
            "help_text": "Please set the parameters needed for finding the mass traces for the library. These more or less follow the same design as the quantification of the biological samples. Please see the description of OpenMS and XCMS above. In brief, if you have selected doing centroiding, you need to change OpenMS PeakPickerHiRes parameter file for the library.\n\nPlease edit the following files (separate for positive and negative):\n\n```bash\n    assets/openms/openms_peak_picker_lib_ini_pos.ini\n```\n\nyou will have to set whether you do the quantification using either OpenMS (set to openms) or XCMS (set to xcms) (**for library**):\n\n```nextflow\n    quantification_openms_xcms_library_pos=\"xcms\"\n```\n\nIf OpenMS selected, please edit the following files for doing mass trace detection for the library:\n\n```bash\n    assets/openms/openms_feature_finder_metabo_lib_ini_pos.ini\n```\n\nIf you have selected to do quantification using XCMS, you need to tune the following parameters (See the corresponding sections in the quantification above):\n\n## Parameters for XCMS and CAMERA (library)\n\nThe same parameters that were set for quantification and adducts identification should be set here for identification. See quantification parameters. \n\nFor example, one can run IPO for setting the parameters for use individual parameters.\n\n## Mapping MS2 to features (within the library)\n\nppm deviation when mapping MS2 parent ion to a mass trace:\n\n```nextflow\n    ppm_mapmsmstocamera_library_pos_msnbase=\"10\"\n```\n\nRT difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace):\n\n```nextflow\n    rt_mapmsmstocamera_library_pos_msnbase=\"5\"\n```\n"
        },
        "internal_library_parameters_positive_mode": {
            "title": "Internal library parameters (positive mode)",
            "type": "object",
            "description": "Parameters used to characterize the internal library",
            "default": "",
            "properties": {
                "raw_file_name_preparelibrary_pos_msnbase": {
                    "type": "string",
                    "default": "rawFile",
                    "description": "name of the column showing which raw files contain which metabolite in the library_description_pos csv file"
                },
                "compund_id_preparelibrary_pos_msnbase": {
                    "type": "string",
                    "default": "HMDB.YMDB.ID",
                    "description": "name of the column showing id of the metabolites in the library_description_pos csv file"
                },
                "compound_name_preparelibrary_pos_msnbase": {
                    "type": "string",
                    "default": "PRIMARY_NAME",
                    "description": "name of the compount column in the library_description_pos csv file"
                },
                "mz_col_preparelibrary_pos_msnbase": {
                    "type": "string",
                    "default": "mz",
                    "description": "name of the mz column in the library_description_pos csv file"
                },
                "which_mz_preparelibrary_pos_msnbase": {
                    "type": "string",
                    "default": "f",
                    "description": "\"f\" or \"c\", showing whether the Feature range or centroid of the feature should be used for mapping",
                    "enum": [
                        "f",
                        "c"
                    ]
                },
                "ncore_searchengine_library_pos_msnbase": {
                    "type": "integer",
                    "default": 1,
                    "description": "Number of cores for mapping the features"
                },
                "ppm_create_library_pos_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm error for mapping the library characterization masses to the experimental one"
                }
            },
            "help_text": "Please set the following parameters based on your library description files\n\nColumn name showing name of the raw file in the library file e.g. \"raw.File\" in the table above:\n\n```nextflow\n    raw_file_name_preparelibrary_pos_msnbase=\"\"\n```\n\nColumn name showing ID of the compound in the library file e.g. \"HMDB.ID\" in the table above:\n\n```nextflow\n    compund_id_preparelibrary_pos_msnbase=\"\"\n```\n\nColumn name showing name of the compound in the library file e.g. \"Name\" in the table above:\n\n```nextflow\n    compound_name_preparelibrary_pos_msnbase=\"\"\n```\n\nColumn name showing m/z of the compound in the library file e.g. \"m.z\" in the table above:\n\n```nextflow\n    mz_col_preparelibrary_pos_msnbase=\"mz\"\n```\n\nThe function can use feature range (f), centroid (c), and parent m/z (Parent) information in order to map a compound to MS1 and MS2 information:\n\n```nextflow\n    which_mz_preparelibrary_pos_msnbase=\"f\"\n```\n\nSet the relative mass deviation (ppm) between the experimental and theoretical masses of metabolites:\n\n```nextflow\n    ppm_create_library_pos_msnbase=10\n```\n\nNumber of cores for mapping the features:\n\n```nextflow\n    ncore_searchengine_library_pos_msnbase=1\n```\n\n"
        },
        "output_preparation_positive_mode": {
            "title": "Output preparation (positive mode)",
            "type": "object",
            "description": "Parameters that control how the results are outputted",
            "default": "",
            "properties": {
                "ppm_output_pos_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "relative difference of mass of the ID hit compare to a mass trace (ppm)"
                },
                "rt_output_pos_camera": {
                    "type": "integer",
                    "default": 5,
                    "description": "retention time difference of ID to mass trace (second)"
                },
                "higher_the_better_output_pos_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "is higher the score the better (not used for now)",
                    "hidden": true
                },
                "impute_output_pos_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "should we impute adduct and different chance states with the same ID"
                },
                "type_column_output_pos_camera": {
                    "type": "string",
                    "default": "Class",
                    "description": "Class of the samples (used for statistics and coverage calculations)"
                },
                "selected_type_output_pos_camera": {
                    "type": "string",
                    "default": "Sample",
                    "description": "what class of samples do you want to keep (anything not matching this in the Class column will be removed)"
                },
                "rename_output_pos_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "you want to rename the files"
                },
                "rename_col_output_pos_camera": {
                    "type": "string",
                    "default": "rename",
                    "description": "which column of the phenotype file to use for renaming"
                },
                "only_report_with_id_output_pos_camera": {
                    "type": "boolean",
                    "default": false,
                    "description": "do only want to see the identified mass traces or everything?"
                },
                "combine_replicate_output_pos_camera": {
                    "type": "boolean",
                    "default": false,
                    "description": "do you have technical replicates you want to average ?"
                },
                "combine_replicate_column_output_pos_camera": {
                    "type": "string",
                    "default": "rep",
                    "description": "which column of the phenotype file show the technical replicates"
                },
                "log_output_pos_camera": {
                    "type": "boolean",
                    "default": true,
                    "description": "should we log2 the output"
                },
                "sample_coverage_output_pos_camera": {
                    "type": "integer",
                    "default": 50,
                    "description": "any mass trace having more pecentage of the missing value will be removed"
                },
                "sample_coverage_method_output_pos_camera": {
                    "type": "string",
                    "default": "global",
                    "description": "how to calculate missing value percentrage? global across all the samples? or name of the column in the phenotype file showing the grouping"
                },
                "ncore_output_pos_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of cores used for mapping the features"
                },
                "normalize_output_pos_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "do you want to normalize the data set to 'NA' if you don't want normalization"
                }
            },
            "help_text": "Each process in the workflow will create a folder with the following pattern:\n(output directory)/process_(name of the process)_(if it is the library or not)_(ionization mode)_(name of the process)\n\nThe most import outputs are the results of process_output that contains three tabular files, one for the peak table, one for the variable information (including identification etc) and metadata information.\n"
        },
        "cfm_id_parameters_positive_mode": {
            "title": "CFM-ID parameters (positive mode)",
            "type": "object",
            "description": "Parameters specific to CFM-ID",
            "default": "",
            "properties": {
                "database_csv_files_pos_cfmid": {
                    "type": "string",
                    "description": "path to a csv file containing your database"
                },
                "ncore_pos_cfmid": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that cfm can use"
                },
                "candidate_id_identification_pos_cfmid": {
                    "type": "string",
                    "default": "Identifier",
                    "description": "name of the column in the database for id of the molecules"
                },
                "candidate_inchi_smiles_identification_pos_cfmid": {
                    "type": "string",
                    "default": "SMILES",
                    "description": "name of the column in the database for smile of the molecules"
                },
                "candidate_mass_identification_pos_cfmid": {
                    "type": "string",
                    "default": "MonoisotopicMass",
                    "description": "name of the column in the database for mass of the molecules"
                },
                "database_name_column_identification_pos_cfmid": {
                    "type": "string",
                    "default": "Name",
                    "description": "name of the column in the database for name of the molecules"
                },
                "database_inchI_column_identification_pos_cfmid": {
                    "type": "string",
                    "default": "InChI",
                    "description": "name of the column in the database for inchi of the molecules"
                }
            },
            "help_text": "You need to specify the database for CFM-ID. The rest of the parameters will be taken from the global parameters. Please see MetFrag parameter on how to construct the database.\nThis database must at least contain the following columns: id of the molecules, smile of the molecules, the mass of the molecules, name of the molecules and InChI of the molecules. The best practice would be to use [MetChem](https://github.com/c-ruttkies/container-metchemdata) to construct the database.\n\nAbsolute path to a csv file containing your database:\n\n```nextflow\n    database_csv_files_pos_cfmid=\"\"\n```\n\nName of the column in the database file for id of the molecules:\n\n```nextflow\n    candidate_id_identification_pos_cfmid=\"Identifier\"\n```\n\nName of the column in the database file for smile of the molecules:\n\n```nextflow\n    candidate_inchi_smiles_identification_pos_cfmid=\"SMILES\"\n```\n\nName of the column in the database file for mass of the molecules:\n\n```nextflow\n    candidate_mass_identification_pos_cfmid=\"MonoisotopicMass\"\n```\n\nName of the column in the database file for name of the molecules:\n\n```nextflow\n    database_name_column_identification_pos_cfmid=\"Name\"\n```\n\nName of the column in the database file for InChI of the molecules:\n\n```nextflow\n    database_inchI_column_identification_pos_cfmid=\"InChI\"\n```\n\nNumber of cores for CFM-ID:\n\n```nextflow\n    ncore_pos_cfmid=2\n```\n"
        },
        "metfrag_parameters_positive_mode": {
            "title": "MetFrag parameters (positive mode)",
            "type": "object",
            "description": "Parameters only for MetFrag",
            "default": "",
            "properties": {
                "database_csv_files_pos_metfrag": {
                    "type": "string",
                    "description": "path to a csv file containing your database"
                },
                "ncore_pos_metfrag": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that metfrag can use"
                }
            },
            "help_text": "We only need two parameters if the global parameters have been set properly. This is the database file. An example of such a database can be found [here](https://raw.githubusercontent.com/nf-core/test-datasets/metaboigniter/hmdb_2017-07-23.csv). You can either use the example for HMDB (2017) or generate your own using [MetChem](https://github.com/c-ruttkies/container-metchemdata). Please contact us if you need to generate this file.\n\nAbsolute path to the generated database file:\n\n```nextflow\n    database_csv_files_pos_metfrag=\"\"\n```\n\nNumber of cores used for Metfrag:\n\n```nextflow\n    ncore_pos_metfrag=2\n```"
        },
        "csi_fingerid_parameters_positive_mode": {
            "title": "CSI:FINGERID parameters (positive mode)",
            "type": "object",
            "description": "Parameters only for CSI:FINGERID",
            "default": "",
            "properties": {
                "database_csifingerid_pos_csifingerid": {
                    "type": "string",
                    "default": "hmdb",
                    "description": "IMPORTANT: we don't support database file for csi:fingerid. You will need to provide what database to use here, the rest of the parameters will be taken from there parameter file"
                },
                "ncore_csifingerid_pos_csifingerid": {
                    "type": "integer",
                    "default": 2,
                    "description": "number of cores that csi can use"
                },
                "timeout_csifingerid_pos_csifingerid": {
                    "type": "integer",
                    "default": 600,
                    "description": "number of seconds that each csi ion can rum (time limit)"
                }
            },
            "help_text": "Please select the database to be used for CSIFingerID. **IMPORTANT: we don't support database file for csi:fingerid. You will need to provide what database to use here, the rest of the parameters will be taken from there parameter file**\n\nDatabase (this will overwrite the corresponding parameter in the input file). CSI:FingerID does not have LocalCSV. So if you set this in the previous step, change this to your desired database (**one of**: all, chebi, kegg, bio, natural products, pubmed, hmdb, biocyc, hsdb, knapsack, biological, zinc bio, gnps, pubchem, mesh, maconda):\n\n```nextflow\n    database_csifingerid_pos_csifingerid=\"hmdb\"\n```\n\nNumber of cores used for CSI:\n\n```nextflow\n    ncore_csifingerid_pos_csifingerid=2\n```\n\nNumber of seconds that each csi ion can rum (time limit)\n\n```nextflow\n    timeout_csifingerid_pos_csifingerid=600\n```"
        },
        "global_identification_parameters_positive_mode": {
            "title": "Global identification parameters (positive mode)",
            "type": "object",
            "description": "Parameters that will be used in all the search engines",
            "default": "",
            "properties": {
                "ppm_mapmsmstocamera_pos_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation when mapping MS2 parent ion to a mass trace"
                },
                "rt_mapmsmstocamera_pos_msnbase": {
                    "type": "integer",
                    "default": 5,
                    "description": "rt difference (in second) for mapping MS2 parent ion to a mass trace (the mass trace is a range, star and end of the trace)"
                },
                "precursorppm_msmstoparam_pos_msnbase": {
                    "type": "integer",
                    "default": 10,
                    "description": "relative mass tolerance of the precursor (ppm)"
                },
                "fragmentppm_msmstoparam_pos_msnbase": {
                    "type": "integer",
                    "default": 20,
                    "description": "relative mass tolerance of the fragment ions (ppm)"
                },
                "fragmentabs_msmstoparam_pos_msnbase": {
                    "type": "number",
                    "default": 0.05,
                    "description": "absolute mass tolerance of the fragment ions"
                },
                "database_msmstoparam_pos_msnbase": {
                    "type": "string",
                    "default": "LocalCSV",
                    "description": "type of database to use (see metaboIGNITER guide)"
                },
                "mode_msmstoparam_pos_msnbase": {
                    "type": "string",
                    "default": "pos",
                    "description": "ionization method. This has to be pos (only for testing at this stage)",
                    "hidden": true
                },
                "adductRules_msmstoparam_pos_msnbase": {
                    "type": "string",
                    "default": "primary",
                    "description": "adduct rules (primary or extended)",
                    "enum": [
                        "primary",
                        "extended"
                    ]
                },
                "minPeaks_msmstoparam_pos_msnbase": {
                    "type": "integer",
                    "default": 2,
                    "description": "ions with less that this number will be removed"
                }
            },
            "help_text": "This module is used to map MS/MS spectra to annotated CAMERA features. The mapping is performed based on retention time and m/z values of the annotated features.\n\nThe ppm error used for the mapping:\n\n```nextflow\n    ppm_mapmsmstocamera_pos_msnbase=\"10\"\n```\n\nThe retention time error (in seconds) used for the mapping:\n\n```nextflow\n    rt_mapmsmstocamera_pos_msnbase=\"5\"\n```\n\n## global parameters (Producing search files)\n\nThis module is used to generate search parameters with mapped MS/MS spectra retrieved from the mzML files. These parameters will be sent to all the search engines. You will then have the possibility to set the search engine specific parameters. The only exception is *database_msmstoparam_pos/neg_msnbase* that is only applicable in **MetFrag**.\n\nThe ppm error for the precursor mass to search candidates:\n\n```nextflow\n    precursorppm_msmstoparam_pos_msnbase=\"10\"\n```\n\nThe ppm error to assign fragments to fragment peaks:\n\n```nextflow\n    fragmentppm_msmstoparam_pos_msnbase=\"20\"\n```\n\nAbsolute mass error to assign fragments to fragment peaks:\n\n```nextflow\n    fragmentabs_msmstoparam_pos_msnbase=\"0.05\"\n```\n\nAvailable databases are KEGG, PubChem, MetChem (a local database that needs to be set up beforehand). In addition, LocalCSV can be used which uses a CSV file for searching. Such a CSV file can be downloaded from [here](https://msbi.ipb-halle.de/~cruttkie/databases/).\nIf LocalCSV is selected, a specific file needs to be provided. The format of this file is very strict. See the database parameter.\n\n```nextflow\n    database_msmstoparam_pos_msnbase=\"LocalCSV\"\n```\n\nAdduct ruleset to be used:\nprimary - contains most common adduct types ([M-H]-, [M-2H+Na]-, [M-2H+K]-, [M+Cl]-, [M+H]+, [M+Na]+, [M+K]+, [M+NH4]+)\nextended - next to primary also additional adduct types\n\n```nextflow\n    adductRules_msmstoparam_pos_msnbase=\"primary\"\n```\n\nFilter spectra by a minimum number of fragment peaks:\n\n```nextflow\n    minPeaks_msmstoparam_pos_msnbase=\"2\"\n```\n"
        },
        "adduct_and_isotope_annotation_positive_mode": {
            "title": "Adduct and isotope annotation (positive mode)",
            "type": "object",
            "description": "Settings for CAMERA to detect adducts and isotopes",
            "default": "",
            "properties": {
                "sigma_group_pos_camera": {
                    "type": "integer",
                    "default": 8,
                    "description": "sigma value for grouping the peaks across chromatogram"
                },
                "perfwhm_group_pos_camera": {
                    "type": "number",
                    "default": 0.6,
                    "description": "full width at half maximum for finding overlaping peaks"
                },
                "intval_group_pos_camera": {
                    "type": "string",
                    "default": "maxo",
                    "description": "which intensity value to use"
                },
                "ppm_findaddcuts_pos_camera": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm deviation between theoritical adduct mass and the experimental one"
                },
                "polarity_findaddcuts_pos_camera": {
                    "type": "string",
                    "default": "positive",
                    "description": "this has to be positive (for testing only)!",
                    "hidden": true
                },
                "maxcharge_findisotopes_pos_camera": {
                    "type": "integer",
                    "default": 1,
                    "description": "number of changes to consider (most often 1 is enough)"
                }
            },
            "help_text": "MetaboIGNITER performs annotation using CAMERA package in R. We first do FWHM grouping, then perform adduct detection followed by isotope finding. The specific details of this can be found on [CAMERA webpage](http://bioconductor.org/packages/release/bioc/html/CAMERA.html).\n\n## CAMERA Group FWHM\n\nGroup peaks of a xsAnnotate object according to there retention time into pseudospectral-groups. Uses the peak FWHMs as grouping borders. Returns xsAnnotate object with pseudospectral information.\nThe multiplier of the standard deviation:\n\n```nextflow\n    sigma_group_pos_camera=\"8\"\n```\n\nPercentage of the width of the FWHM:\n\n```nextflow\n    perfwhm_group_pos_camera=\"0.6\"\n```\n\nIntensity values for ordering. Allowed values are into, maxo, intb\"\n\n```nextflow\n    intval_group_pos_camera=\"maxo\"\n```\n\n## CAMERA Find Adducts\n\nAnnotate adducts (and fragments) for a xsAnnotate object. Returns a xsAnnotate object with annotated pseudospectra:\n\nThe ppm error for the search:\n\n```nextflow\n    ppm_findaddcuts_pos_camera=\"10\"\n```\n\n## CAMERA Find Isotopes\n\nAnnotate isotope peaks for a xsAnnotate object. Returns a xsAnnotate object with annotated isotopes.\n\nMax. number of the isotope charge:\n\n```nextflow\n    maxcharge_findisotopes_pos_camera=1\n```\n"
        },
        "filtering_parameters_positive_mode": {
            "title": "Filtering parameters (positive mode)",
            "type": "object",
            "description": "Parameters to use for performing QC, blank and dilution filtering",
            "default": "",
            "properties": {
                "blank_filter_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "set to true if you want to remove signal from blank"
                },
                "method_blankfilter_pos_xcms": {
                    "type": "string",
                    "default": "max",
                    "description": "method of sumarization of signal in blank samples"
                },
                "blank_blankfilter_pos_xcms": {
                    "type": "string",
                    "default": "Blank",
                    "description": "Name of the class of the blank samples"
                },
                "sample_blankfilter_pos_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "Name of the class of the biological samples"
                },
                "rest_blankfilter_pos_xcms": {
                    "type": "string",
                    "default": "T",
                    "description": "set to T to compare blanks only to rest of the samples"
                },
                "dilution_filter_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "Select whether you want to do dilution filtering"
                },
                "corto_dilutionfilter_pos_xcms": {
                    "type": "string",
                    "default": "0.5,1,2,4",
                    "description": "The class of the samples represneting dilution. This has to be separated by comma!"
                },
                "dilution_dilutionfilter_pos_xcms": {
                    "type": "string",
                    "default": "D1,D2,D3,D4",
                    "description": "The class of the samples represneting dilution. This has to be separated by comma!"
                },
                "pvalue_dilutionfilter_pos_xcms": {
                    "type": "number",
                    "default": 0.05,
                    "description": "p-value of the correlation. Anything higher than this will be removed!"
                },
                "corcut_dilutionfilter_pos_xcms": {
                    "type": "integer",
                    "default": -1,
                    "description": "minimum expected correlation. Aniything lower than this will be removed!"
                },
                "abs_dilutionfilter_pos_xcms": {
                    "type": "string",
                    "default": "F",
                    "description": "If the tool should consider absolute correlation rather than the typical one from [-1 to 1] (F or T)",
                    "enum": [
                        "F",
                        "T"
                    ]
                },
                "cv_filter_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "select to whether perfrom cv filtering or not"
                },
                "qc_cvfilter_pos_xcms": {
                    "type": "string",
                    "default": "QC",
                    "description": "class of your QC samples"
                },
                "cvcut_cvfilter_pos_xcms": {
                    "type": "number",
                    "default": 0.3,
                    "description": "Maximum coefficient of variation you expect. Anything higher than this will be removed!"
                }
            },
            "help_text": "## Signal filtering\n\nAs described above, currently we support three types of signal filtering. You can turn them on and off depending on the availability of the data, experimental design or if you wish to do the manually later.\n\n## Blank filtering\n\nThe first method is *blank filtering*. This module filters out the signals that have higher abundance in non-biological samples (e.g. blank) compared to biological samples.\n\nIf you don't want to perform the blank filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\n    blank_filter_pos\n```\n\nWhich method to use for summarizing blank and biological sample for comparisons. For example, if Max is selected, a signal will be removed if it maximum abundance in the blank samples is higher than maximum abundance in biological samples (one of max, mean, median):\n\n```nextflow\n    method_blankfilter_pos_xcms=\"max\"\n```\n\nThis must indicate the class of blank samples exactly as you refer to them in your phenotype file. IMPORTANT: This class should be identical for all the blank samples:\n\n```nextflow\n    blank_blankfilter_pos_xcms\n```\n\nIf true, the (average, median, max) abundance of blank samples will be compared against all other samples. For false see the next parameter:\n\n```nextflow\n    rest_blankfilter_pos_xcms=\"true\"\n```\n\nIf the previous parameter is false, a sample class can be specified so that blank abundance will be compared against this sample class:\n\n```nextflow\n    sample_blankfilter_pos_xcms\n```\n\n## Dilution filtering\n\nThis module filters out the signals that do not correlate with a specified dilution trend.\nIf you don't want to perform the dilution filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\n    dilution_filter_pos\n```\n\nThis series will used for calculation of correlation. For example if this parameter is set like 1,2,3 and the class of dilution trends is set as D1,D2,D3 the following the pairs will be used for calculating the correlation: (D1,1),(D2,2),(D3,3):\n\n```nextflow\n    corto_dilutionfilter_pos_xcms=\"0.5,1,2,4\"\n```\n\nThis must indicate the class of dilution trend samples. IMPORTANT: the samples are correlated to the exact order of the sequence as set here:\n\n```nextflow\n    dilution_dilutionfilter_pos_xcms=\"D1,D2,D3,D4\"\n```\n\nSignals with correlation p-value higher than this will be removed:\n\n```nextflow\n    pvalue_dilutionfilter_pos_xcms=\"0.05\"\n```\n\nSignals with lower correlation than this will be removed:\n\n```nextflow\n    corcut_dilutionfilter_pos_xcms=\"-1\"\n```\n\nShould the algorithm use the correlation as it is (negative and positive) or absolute correlation (either true or false):\n\n```nextflow\n    abs_dilutionfilter_pos_xcms=\"false\"\n```\n\n## CV filtering\n\nThis module filters out the signals that do not show the desired coefficient of variation.\nIf you don't want to perform the CV filtering. Set the following to *false* and go to the next step of the workflow (no need to set the parameters for this step!):\n\n```nextflow\ncv_filter_pos\n```\n\nThis must indicate the class of QC samples:\n\n```nextflow\n    qc_cvfilter_pos_xcms=\"QC\"\n```\n\nSignals with CVs higher than this will be removed:\n\n```nextflow\n    cvcut_cvfilter_pos_xcms=0.3\n```"
        },
        "quantification_parameter_positive_mode": {
            "title": "Quantification parameter (positive mode)",
            "type": "object",
            "description": "Parameters for quantification",
            "default": "",
            "properties": {
                "quantification_openms_xcms_pos": {
                    "type": "string",
                    "default": "xcms",
                    "description": "set whether you want to do quantification with OpenMS (openms) or XCMS (xcms) in positive ionization",
                    "enum": [
                        "xcms",
                        "openms"
                    ]
                },
                "performIPO_pos": {
                    "type": "string",
                    "default": "none",
                    "description": "controls how to perform IPO possible values: \"none\": don't perform IPO, \"global\": performs IPO on all or selected number of samples. \"global_quant\": perform IPO only for quantification (not retention time correction and grouping), \"local\": performs IPO on individual samples one at the time. \"local_quant\": performs IPO on individual samples only for quantification, \"local_RT\": performs IPO on only for retention time correction and grouping.",
                    "enum": [
                        "none",
                        "global",
                        "global_quant",
                        "local",
                        "local_quant",
                        "local_RT"
                    ]
                },
                "ipo_allSamples_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "Performs IPO on all the samples irrespective of the class they have"
                },
                "ipo_columnToSelect_pos": {
                    "type": "string",
                    "default": "Class",
                    "description": "If ipo_allSamples_pos is false, one must pass the phenotype file to select sample. This parameter select the column of the phenotype file."
                },
                "ipo_valueToSelect_pos": {
                    "type": "string",
                    "default": "QC",
                    "description": "Selects the files only with this value in the columnToSelect column"
                },
                "ipo_methodXset_pos": {
                    "type": "string",
                    "default": "centWave",
                    "description": "Quantification methods for IPO. Only centWave is supported at this stage."
                },
                "ipo_noise_l_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "lowest level of noise"
                },
                "ipo_noise_h_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "highest level of noise"
                },
                "ipo_snthresh_l_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "lowest level of signal to noise threshold"
                },
                "ipo_snthresh_h_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "highest level of signal to noise threshold"
                },
                "ipo_mzCenterFun_pos": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function for centering the mz"
                },
                "ipo_integrate_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "ipo_fitgauss_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitte"
                },
                "ipo_min_peakwidth_l_pos": {
                    "type": "integer",
                    "default": 12,
                    "description": "lower minimum width of peaks"
                },
                "ipo_min_peakwidth_h_pos": {
                    "type": "integer",
                    "default": 28,
                    "description": "higher minimum width of peaks"
                },
                "ipo_max_peakwidth_l_pos": {
                    "type": "integer",
                    "default": 35,
                    "description": "lower maximum width of peaks"
                },
                "ipo_max_peakwidth_h_pos": {
                    "type": "integer",
                    "default": 65,
                    "description": "higher maximum width of peaks"
                },
                "ipo_ppm_l_pos": {
                    "type": "integer",
                    "default": 17,
                    "description": "lower ppm mass deviation"
                },
                "ipo_ppm_h_pos": {
                    "type": "integer",
                    "default": 32,
                    "description": "higher ppm mass deviation"
                },
                "ipo_mzdiff_l_pos": {
                    "type": "number",
                    "default": -0.001,
                    "description": "lower minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_mzdiff_h_pos": {
                    "type": "number",
                    "default": 0.01,
                    "description": "higher minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "ipo_charge_camera_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "maximum charge of molecules (only used in individual setting)"
                },
                "ipo_max_ppm_camera_pos": {
                    "type": "integer",
                    "default": 10,
                    "description": "ppm mass deviation for adducts (only used in individual setting)"
                },
                "ipo_prefilter_l_l_pos": {
                    "type": "integer",
                    "default": 3,
                    "description": "lower value of K in 'prefilter_pos=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_pos= 'I'."
                },
                "ipo_prefilter_l_h_pos": {
                    "type": "integer",
                    "default": 3,
                    "description": "higher value of K in 'prefilter_pos=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >_pos= 'I'."
                },
                "ipo_prefilter_h_l_pos": {
                    "type": "integer",
                    "default": 100,
                    "description": "lower I in prefilter"
                },
                "ipo_prefilter_h_h_pos": {
                    "type": "integer",
                    "default": 100,
                    "description": "higher I in prefilter"
                },
                "ipo_ncores_pos": {
                    "type": "integer",
                    "default": 5,
                    "description": "number of cores used in IPO"
                },
                "ipo_gapInit_l_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "lower Penalty for Gap opening"
                },
                "ipo_gapInit_h_pos": {
                    "type": "number",
                    "default": 0.4,
                    "description": "higher Penalty for Gap opening"
                },
                "ipo_gapExtend_l_pos": {
                    "type": "number",
                    "default": 2.1,
                    "description": "lower Penalty for Gap enlargement"
                },
                "ipo_gapExtend_h_pos": {
                    "type": "number",
                    "default": 2.7,
                    "description": "higher Penalty for Gap enlargement"
                },
                "ipo_profStep_l_pos": {
                    "type": "number",
                    "default": 0.7,
                    "description": "lower step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_profStep_h_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher step size (in m/z) to use for profile generation from the raw data files"
                },
                "ipo_response_l_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_response_h_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "ipo_factorDiag_l_pos": {
                    "type": "integer",
                    "default": 2,
                    "description": "lower Local weighting applied to diagonal moves in alignment"
                },
                "ipo_factorDiag_h_pos": {
                    "type": "integer",
                    "default": 2,
                    "description": "higher Local weighting applied to diagonal moves in alignment"
                },
                "ipo_factorGap_l_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower Local weighting applied to gap moves in alignment"
                },
                "ipo_factorGap_h_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher Local weighting applied to gap moves in alignment"
                },
                "ipo_localAlignment_pos": {
                    "type": "integer",
                    "default": 0,
                    "description": "Local rather than global alignment"
                },
                "ipo_bw_l_pos": {
                    "type": "integer",
                    "default": 22,
                    "description": "lower bandwidth (consider something like retention time differences)"
                },
                "ipo_bw_h_pos": {
                    "type": "integer",
                    "default": 38,
                    "description": "higher bandwidth (consider something like retention time differences)"
                },
                "ipo_minfrac_l_pos": {
                    "type": "number",
                    "default": 0.3,
                    "description": "lower minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minfrac_h_pos": {
                    "type": "number",
                    "default": 0.7,
                    "description": "higher minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_mzwid_l_pos": {
                    "type": "number",
                    "default": 0.015,
                    "description": "lower mz width (mz differences)"
                },
                "ipo_mzwid_h_pos": {
                    "type": "number",
                    "default": 0.035,
                    "description": "higher mz width (mz differences)"
                },
                "ipo_minsamp_l_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "lower minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_minsamp_h_pos": {
                    "type": "integer",
                    "default": 1,
                    "description": "higher minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "ipo_max_l_pos": {
                    "type": "integer",
                    "default": 50,
                    "description": "lower maximum number of groups to identify in a single m/z slice"
                },
                "ipo_max_h_pos": {
                    "type": "integer",
                    "default": 50,
                    "description": "higher maximum number of groups to identify in a single m/z slice"
                },
                "ipo_distFunc_pos": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)"
                },
                "ipo_methodRT_pos": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "Only obiwarp is supported"
                },
                "masstrace_ppm_pos_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "masstrance deviation in ppm"
                },
                "peakwidthlow_quant_pos_xcms": {
                    "type": "integer",
                    "default": 5,
                    "description": "lower width of peaks"
                },
                "peakwidthhigh_quant_pos_xcms": {
                    "type": "integer",
                    "default": 30,
                    "description": "highest width of peaks"
                },
                "noise_quant_pos_xcms": {
                    "type": "integer",
                    "default": 1000,
                    "description": "level of noise"
                },
                "mzdiff_quant_pos_xcms": {
                    "type": "number",
                    "default": -0.001,
                    "description": "minimum difference in m/z for peaks with overlapping retention times, can be negative to allow overlap"
                },
                "snthresh_quant_pos_xcms": {
                    "type": "integer",
                    "default": 10,
                    "description": "signal to noise ratio cutoff, definition see below."
                },
                "prefilter_quant_pos_xcms": {
                    "type": "integer",
                    "default": 3,
                    "description": "K in 'prefilter=c(k,I)'. Prefilter step for the first phase. Mass traces are only retained if they contain at least 'k' peaks with intensity >= 'I'."
                },
                "value_of_prefilter_quant_pos_xcms": {
                    "type": "integer",
                    "default": 100,
                    "description": "I in prefilter"
                },
                "mzCenterFun_quant_pos_xcms": {
                    "type": "string",
                    "default": "wMean",
                    "description": "Function to calculate the m/z center of the feature: 'wMean' intensity weighted mean of the feature m/z values, 'mean' mean of the feature m/z values, 'apex' use m/z value at peak apex, 'wMeanApex3' intensity weighted mean of the m/z value at peak apex and the m/z value left and right of it, 'meanApex3' mean of the m/z value at peak apex and the m/z value left and right of it."
                },
                "integrate_quant_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Integration method. If '=1' peak limits are found through descent on the mexican hat filtered data, if '=2' the descent is done on the real data. Method 2 is very accurate but prone to noise, while method 1 is more robust to noise but less exact."
                },
                "fitgauss_quant_pos_xcms": {
                    "type": "boolean",
                    "default": false,
                    "description": "logical, if TRUE a Gaussian is fitted"
                },
                "phenodatacolumn_quant_pos": {
                    "type": "string",
                    "default": "Class",
                    "description": "name of the column in the phenotype_design_pos showing class information of the samples"
                },
                "sampleclass_quant_pos_xcms": {
                    "type": "string",
                    "default": "Sample",
                    "description": "A name for the class of sample"
                },
                "method_align_N1_pos_xcms": {
                    "type": "string",
                    "default": "obiwarp",
                    "description": "name of the method for correcting the RT shifts."
                },
                "profStep_align_N1_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "step size (in m/z) to use for profile generation from the raw data files"
                },
                "center_align_N1_pos_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "the index of the sample all others will be aligned to. If center==NULL, the sample with the most peaks is chosen as default."
                },
                "response_align_N1_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Responsiveness of warping.  0 will give a linear warp based on start and end points.  100 will use all bijective anchors"
                },
                "distFunc_align_N1_pos_xcms": {
                    "type": "string",
                    "default": "cor_opt",
                    "description": "DistFunc function: cor (Pearson's R) or cor_opt (default, calculate only 10% diagonal band of distance matrix, better runtime), cov (covariance), prd (product), euc (Euclidean distance)",
                    "enum": [
                        "cor",
                        "cor_opt",
                        "cov",
                        "prd",
                        "euc"
                    ]
                },
                "gapInit_align_N1_pos_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "Penalty for Gap opening"
                },
                "gapExtend_align_N1_pos_xcms": {
                    "type": "string",
                    "default": "NULL",
                    "description": "Penalty for Gap enlargement"
                },
                "factorDiag_align_N1_pos_xcms": {
                    "type": "integer",
                    "default": 2,
                    "description": "Local weighting applied to diagonal moves in alignment"
                },
                "factorGap_align_N1_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "Local weighting applied to gap moves in alignment"
                },
                "localAlignment_align_N1_pos_xcms": {
                    "type": "integer",
                    "default": 0,
                    "description": "Local rather than global alignment"
                },
                "bandwidth_group_N1_pos_xcms": {
                    "type": "integer",
                    "default": 15,
                    "description": "bandwidth (consider something like retention time differences)"
                },
                "mzwid_group_N1_pos_xcms": {
                    "type": "number",
                    "default": 0.005,
                    "description": "mz width (mz differences)"
                },
                "minfrac_group_N1_pos_xcms": {
                    "type": "number",
                    "default": 0.5,
                    "description": "minimum fraction of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "minsamp_group_N1_pos_xcms": {
                    "type": "integer",
                    "default": 1,
                    "description": "minimum number of samples necessary in at least one of the sample groups for it to be a valid group"
                },
                "max_group_N1_pos_xcms": {
                    "type": "integer",
                    "default": 50,
                    "description": "maximum number of groups to identify in a single m/z slice"
                }
            },
            "help_text": "## Automatic parameter selection\n\nMetaboIGNITER supports parameter detection using IPO. MetaboIGNITER can run IPO on pos, neg and library separately. Here we demonstrate the usage for the positive ionization method.\nThe same principles apply to negative and library mode. If you decided to go with a full IPO, you won't need to set other parameters.\nIn order to turn this parameter on, one should use:\n\n```nextflow\n    performIPO_pos=\"none\"\n```\n\nThe default parameter sets IPO to off, you can control how to perform IPO using possible values: \"none\": don't perform IPO, \"global\": performs IPO on all or selected number of samples. \"global_quant\": perform IPO only for quantification (not retention time correction and grouping), \"local\": performs IPO on individual samples one at the time. \"local_quant\": performs IPO on individual samples only for quantification, \"local_RT\": performs IPO only for retention time correction and grouping.\n\nThere are several parameters that need to be set for IPO to optimize. If you don't want to optimize a parameter, set its higher and lower boundaries to the same value. The parameters for IPO starts with \"ipo_\"\n\n## XCMS\n\nThis is the default behaviour of the workflow. You need to set the following parameters that end in \"xcms\"\n\nIn addition, the following should show the column name in the CSV file representing the class of the metabolite. In the case of the above phenotype table it should be set to Class:\n\n```nextflow\n    phenodatacolumn_quant_pos=\"Class\"\n```\n"
        },
        "library_controls_and_files_negative_mode": {
            "title": "Library controls and files (negative mode)",
            "type": "object",
            "description": "Input files includes mzML files and settings for performing identification using internal library",
            "default": "",
            "properties": {
                "library_charactrized_neg": {
                    "type": "boolean",
                    "default": false,
                    "description": "if you have already charaztrized your negative library set this to true and specify the path for library_charactrization_file_neg"
                },
                "library_charactrization_file_neg": {
                    "type": "string",
                    "description": "path to the file from charaztrized library (negative)"
                },
                "quant_library_mzml_files_neg": {
                    "type": "string",
                    "description": "Path to a folder containing library mzML files used for doing adduct calcculation (MS1 data in megative ionization method)"
                },
                "id_library_mzml_files_neg": {
                    "type": "string",
                    "description": "Path to a folder containing mzML files used for doing identification (MS2 data in negative ionization method)"
                },
                "library_description_neg": {
                    "type": "string",
                    "description": "Path to a csv file containing description of the library for negative (see the help)"
                }
            },
            "help_text": "This part of the workflow is used to create and characterize in-house library. This is how it works: we assume that the library consists of one or more mzML files, each containing a number of compounds. A possible scenario is when the users have several standard metabolites that can have overlapping masses with unknown retention times. The standards with overlapping masses can be run separately using MS, resulting in different runs. MetaboIGNITER will help you to characterize this type of internal libraries. You will need to construct the Characterization file (see below) that shows which standards are present in which mzML file. The workflow will then do mass trace detection, MS2 extraction and mapping of parent ions to mass traces. Doing so will result in finding the retention time and empirical m/z of each standard. This will then be used to create identification parameters and search the biological MS2 files.\n\nYou will need to place positive and negative files in different folders. In the following example, we provide the complete folder structure used for doing quantification, in-silico and library identification. In this example, we have plcaed the library files in mzML_NEG_Lib and mzML_neg_Lib folders.\n\n```bash\n    Mydata\n    ├── hmdb_2017-07-23.csv\n    ├── library_charac_neg.csv\n    ├── library_charac_neg.csv\n    ├── mzML_NEG_ID\n    │   ├── Pilot_MS_Control_2_Neg_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_Neg_peakpicked.mzML\n    ├── mzML_NEG_Lib\n    │   ├── P1rA_NEG.mzML\n    │   ├── P1rB_NEG.mzML\n    │   ├── P1rC_NEG.mzML\n    │   └── P1rD_NEG.mzML\n    ├── mzML_NEG_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── mzML_neg_ID\n    │   ├── Pilot_MS_Control_2_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_peakpicked.mzML\n    ├── mzML_neg_Lib\n    │   ├── P1rA_neg_180522155214.mzML\n    │   ├── P1rB_neg_180522163438.mzML\n    │   ├── P1rC_neg_180522171703.mzML\n    │   └── P1rD_neg_180522175927.mzML\n    ├── mzML_neg_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── phenotype_negative.csv\n    ├── phenotype_negitive.csv\n```\n\nNow set the folder paths to the library files.\na glob path to a folder containing library mzML files used for doing adduct calculation. If you don't have separate quantification data for the library, set this to the path of the library file:\n\n```nextflow\n    quant_library_mzml_files_neg=\"\"\n```\n\na glob path to a folder containing mzML files (for library) used for doing identification (as described above):\n\n```nextflow\n    id_library_mzml_files_neg=\"\"\n```\n\nFor example, considering the structure above, we can set *quant_library_mzml_files_neg* and *id_library_mzml_files_neg* to \"mydata/mzML_neg_Lib/\\*.mzML\" and *quant_library_mzml_files_neg* and *id_library_mzml_files_neg* to \"mydata/mzML_NEG_Lib/\\*.mzML\".\n\n## Create your library description files\n\nYou need to fix for each of the ionization mode, a separate library description file. An example of such file is provided [here](https://raw.githubusercontent.com/nf-core/test-datasets/metaboigniter/library_charac_neg.csv). This file must contain the following information in a comma separate file:\n\n- Name of the mzML file containing the compound\n\n- ID of the compound e.g. HMDB ID\n\n- Name of the compound\n\n- Theoretical m/z of the compound\n\nHere is an example of the expected table format:\n\n| raw.File| HMDB.ID      | Name               | m.z           |\n|--|--|--|--|\n| a1.mzML | HMDB0000044  | Ascorbic acid      | 177.032087988 |\n| a1.mzML | HMDB0000001  | 1-Methylhistidine  | 170.085126611 |\n| a2.mzML | HMDB0000002  | 1,3-Diaminopropane | 75.08439833   |\n\nAbsolute path to a csv file containing description of the library:\n\n```nextflow\n    library_description_neg=\"\"\n```\n\n\nIf you already have your library characterize e.g the results of *process_collect_library_pos_msnbase* and *process_collect_library_neg_msnbase*. You can set the following parameters to true and also set the absolute paths to the characterization file:\n\nIf you have already characterized your library, set this to true and specify the path for library_charactrization_file_pos/neg:\n\n```nextflow\n    library_charactrized_neg=true\n```\n\nAbsolute path to the file from characterized library:\n\n```nextflow\n    library_charactrization_file_neg=\"\"\n```\nUsing this option will prevent the re-characterization of the library."
        },
        "library_controls_and_files_positive_mode": {
            "title": "Library controls and files (positive mode)",
            "type": "object",
            "description": "Input files includes mzML files and settings for performing identification using internal library",
            "default": "",
            "properties": {
                "library_charactrized_pos": {
                    "type": "boolean",
                    "default": false,
                    "description": "if you have already charaztrized your positive library set this to true and specify the path for library_charactrization_file_pos"
                },
                "library_charactrization_file_pos": {
                    "type": "string",
                    "description": "path to the file from charaztrized library (positive)"
                },
                "quant_library_mzml_files_pos": {
                    "type": "string",
                    "description": "Path to a folder containing library mzML files used for doing adduct calcculation (MS1 data in positive ionization method)"
                },
                "id_library_mzml_files_pos": {
                    "type": "string",
                    "description": "Path to a folder containing mzML files used for doing identification (MS2 data in positive ionization method)"
                },
                "library_description_pos": {
                    "type": "string",
                    "description": "Path to a csv file containing description of the library for positive (see the help)"
                }
            },
            "help_text": "This part of the workflow is used to create and characterize in-house library. This is how it works: we assume that the library consists of one or more mzML files, each containing a number of compounds. A possible scenario is when the users have several standard metabolites that can have overlapping masses with unknown retention times. The standards with overlapping masses can be run separately using MS, resulting in different runs. MetaboIGNITER will help you to characterize this type of internal libraries. You will need to construct the Characterization file (see below) that shows which standards are present in which mzML file. The workflow will then do mass trace detection, MS2 extraction and mapping of parent ions to mass traces. Doing so will result in finding the retention time and empirical m/z of each standard. This will then be used to create identification parameters and search the biological MS2 files.\n\nYou will need to place positive and negative files in different folders. In the following example, we provide the complete folder structure used for doing quantification, in-silico and library identification. In this example, we have placed the library files in mzML_NEG_Lib and mzML_POS_Lib folders.\n\n```bash\n    Mydata\n    ├── hmdb_2017-07-23.csv\n    ├── library_charac_neg.csv\n    ├── library_charac_pos.csv\n    ├── mzML_NEG_ID\n    │   ├── Pilot_MS_Control_2_Neg_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_Neg_peakpicked.mzML\n    ├── mzML_NEG_Lib\n    │   ├── P1rA_NEG.mzML\n    │   ├── P1rB_NEG.mzML\n    │   ├── P1rC_NEG.mzML\n    │   └── P1rD_NEG.mzML\n    ├── mzML_NEG_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── mzML_POS_ID\n    │   ├── Pilot_MS_Control_2_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_peakpicked.mzML\n    ├── mzML_POS_Lib\n    │   ├── P1rA_POS_180522155214.mzML\n    │   ├── P1rB_POS_180522163438.mzML\n    │   ├── P1rC_POS_180522171703.mzML\n    │   └── P1rD_POS_180522175927.mzML\n    ├── mzML_POS_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── phenotype_negative.csv\n    ├── phenotype_positive.csv\n```\n\nNow set the folder paths to the library files.\na glob path to a folder containing library mzML files used for doing adduct calculation. If you don't have separate quantification data for the library, set this to the path of the library file:\n\n```nextflow\n    quant_library_mzml_files_pos=\"\"\n```\n\na glob path to a folder containing mzML files (for library) used for doing identification (as described above):\n\n```nextflow\n    id_library_mzml_files_pos=\"\"\n```\n\nFor example, considering the structure above, we can set *quant_library_mzml_files_pos* and *id_library_mzml_files_pos* to \"mydata/mzML_POS_Lib/\\*.mzML\" and *quant_library_mzml_files_neg* and *id_library_mzml_files_neg* to \"mydata/mzML_NEG_Lib/\\*.mzML\".\n\n## Create your library description files\n\nYou need to fix for each of the ionization mode, a separate library description file. An example of such file is provided [here](https://raw.githubusercontent.com/nf-core/test-datasets/metaboigniter/library_charac_pos.csv). This file must contain the following information in a comma separate file:\n\n- Name of the mzML file containing the compound\n\n- ID of the compound e.g. HMDB ID\n\n- Name of the compound\n\n- Theoretical m/z of the compound\n\nHere is an example of the expected table format:\n\n| raw.File| HMDB.ID      | Name               | m.z           |\n|--|--|--|--|\n| a1.mzML | HMDB0000044  | Ascorbic acid      | 177.032087988 |\n| a1.mzML | HMDB0000001  | 1-Methylhistidine  | 170.085126611 |\n| a2.mzML | HMDB0000002  | 1,3-Diaminopropane | 75.08439833   |\n\nAbsolute path to a csv file containing description of the library:\n\n```nextflow\n    library_description_pos=\"\"\n```\n\nIf you already have your library characterize e.g the results of *process_collect_library_pos_msnbase* and *process_collect_library_neg_msnbase*. You can set the following parameters to true and also set the absolute paths to the characterization file:\n\nIf you have already characterized your library, set this to true and specify the path for library_charactrization_file_pos/neg:\n\n```nextflow\n    library_charactrized_pos=true\n```\n\nAbsolute path to the file from characterized library:\n\n```nextflow\n    library_charactrization_file_pos=\"\"\n```\nUsing this option will prevent the re-characterization of the library."
        },
        "identification_input_files": {
            "title": "Identification input files",
            "type": "object",
            "description": "Input files includes mzML files for performing identification",
            "default": "",
            "properties": {
                "id_mzml_files_pos": {
                    "type": "string",
                    "description": "ath to a folder containing mzML files used for doing identification (MS2 data in positive ionization method)"
                },
                "id_mzml_files_neg": {
                    "type": "string",
                    "description": "Path to a folder containing mzML files used for doing identification (MS2 data in negative ionization method)"
                }
            },
            "help_text": "Before proceeding with setting the parameters for identification you need to complete the mzML folder structure.\n\nThis basically follows the same design as the MS1 data preparation. You need to create separate directories for mzML files that contain MS2 information. So if you have MS2 files in both positive and negative mode, you need to create two more folders. For example, mzML_NEG_ID and mzML_POS_ID containing, negative and positive MS2 data respectively. The following file tree shows an example of such a structure. In this example, we have both positive and negative ionization. The files have been placed in different folders depending on the ionization and pre-processing needed.\n\n```bash\n    Mydata\n    ├── hmdb_2017-07-23.csv\n    ├── mzML_NEG_ID\n    │   ├── Pilot_MS_Control_2_Neg_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_Neg_peakpicked.mzML\n    ├── mzML_NEG_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── mzML_POS_ID\n    │   ├── Pilot_MS_Control_2_peakpicked.mzML\n    │   └── Pilot_MS_Pool_2_peakpicked.mzML\n    ├── mzML_POS_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── phenotype_negative.csv\n    ├── phenotype_positive.csv\n```\n\nWhen you are ready with the folder structure you will need to set the parameters needed:\nA glob path to a folder containing mzML files used for doing identification (MS2 data in positive ionization method)\n\n```nextflow\n    id_mzml_files_pos =\"\"\n```\n\nA glob path to a folder containing mzML files used for doing identification (MS2 data in negative ionization method)\n\n```nextflow\n    id_mzml_files_neg=\"\"\n```\n\nfor example:\n\n```nextflow\n   input =\"/User/XXX/myfiles/id_mzml_files_pos/*mzML\"\n```\n\nIf your quantification files also include MS2 data, you can set *id_mzml_files_pos* and *id_mzml_files_neg* to the path of MS1 data (of course to respective ionization modes)"
        },
        "control_parameters": {
            "title": "Control parameters",
            "type": "object",
            "description": "Used to control functionality of the workflow e.g identification, quantification etc",
            "default": "",
            "properties": {
                "publishDir_intermediate": {
                    "type": "boolean",
                    "default": false,
                    "description": "set to true to publish all the middle stages"
                },
                "perform_identification": {
                    "type": "boolean",
                    "default": false,
                    "description": "Set to false if you don't want to do identification. You will not require to set MS2 related parameters if you set this to false"
                },
                "perform_identification_metfrag": {
                    "type": "boolean",
                    "default": false,
                    "description": "Should Metfrag be used for doing identification?"
                },
                "perform_identification_csifingerid": {
                    "type": "boolean",
                    "default": false,
                    "description": "Should CSI:FingerID be used for doing identification?"
                },
                "perform_identification_cfmid": {
                    "type": "boolean",
                    "default": false,
                    "description": "Should CFM-ID be used for doing identification?"
                },
                "perform_identification_internal_library": {
                    "type": "boolean",
                    "default": false,
                    "description": "Should an internal library be used for doing identification?"
                },
                "type_of_ionization": {
                    "type": "string",
                    "default": "neg",
                    "description": "You can either set to 'pos' (only positive), 'neg' (only negative), 'both' (both positive and negative).",
                    "enum": [
                        "pos",
                        "neg"
                    ]
                },
                "need_centroiding": {
                    "type": "boolean",
                    "description": "Set to true if your data is in profile mode (only for quantification!)"
                }
            },
            "help_text": "## Centroiding\n\nWe recommend inputting already centroided files. You can achieve this at the conversion steps in msconvert. However, if your data is not centroided, you can let the workflow doing that for you. We use OpenMS \"PeakPickHiRes\" tool to perform that. Set the following parameter to *true* to perform the centroiding:\n\n```nextflow\n    need_centroiding\n```\n\nPlease be aware that setting need_centroiding=true will do centroiding on all of your data including both ionization, identification etc.\n\nIf you want non-defualt values, to control the parameters centroiding you can edit *openms_peak_picker_ini_pos.ini* and *openms_peak_picker_ini_neg.ini* files located under *metaboigniter/assets/openms*. The description of the parameters can be found on [OpenMS website](https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/nightly/html/TOPP_PeakPickerHiRes.html).\n\nIf you choose to perform the quantification using OpenMS, you should consider changing the parameters for OpenMS only. You can edit *openms_feature_finder_metabo_ini_pos.ini* and *openms_feature_finder_metabo_ini_neg.ini* files located under *metaboigniter/assets/openms*. The description of the parameters can be found on [OpenMS website](https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/nightly/html/TOPP_FeatureFinderMetabo.html). **When tuning the OpenMS parameters make sure that \"report_convex_hulls\" is set to true**\n\n## Ionization\n\nSet what type of ionization you have. You can either set to 'pos' (only positive), 'neg' (only negative), 'both' (both positive and negative):\n\n```nextflow\n      type_of_ionization\n```\n\n## Identification Specific Parameters\n\nMetaboIGNITER has a specific design for performing identification. After performing quantification and annotation of MS1 data, the results will be fed into the identification sub-pipeline this part of the workflow, will first extract the MS2 information from the identification mzML files and map them to the quantification data. If a parent ion was matched against a feature that was successfully annotated, we then estimate the neutral mass for that parent ion. By doing that, the number of searches needed for identification will significantly decrease. The rest of the ions that were matched against features without annotation will be searched using different adduct rules and charges. The resulting scores from metabolite spectrum matches will be transformed into posterior error probability and re-matched to the features at the later step.\n\nCurrently, MetaboIGNITER supports two types of identification. One is based on in-silico (database) approach and the other is based on internal library.\n\nIf you would like to perform identification, please set the following parameters to true:\n\n```nextflow\n    perform_identification=true\n```\n\nPlease also remember that we only perform identification for the ionization modes that you have quantification data for.\n\n## In-silico identification in MetaboIGNITER\n\nCurrently, MetaboIGNITER supports three search engines, [MetFrag](https://ipb-halle.github.io/MetFrag/), [CSI:FingerID](https://bio.informatik.uni-jena.de/software/sirius/), and [CFM-ID](https://cfmid.wishartlab.com/) for performing identification. These engines share some global parameters but also each of these will need specific set of parameters. The user can select multiple search engines to do the identification. In the case of multiple search engines, the workflow will have multiple final output, one for each search engine and ionization. Please set the parameter to true for the desired search engine:\n\n```nextflow\n    perform_identification_metfrag=false \n    perform_identification_csifingerid=false\n    perform_identification_cfmid=false \n```\n\nCharacterize your own library\n\nThis part of the workflow is used to create and characterize in-house library. This is how it works: we assume that the library consists of one or more mzML files, each containing a number of compounds. A possible scenario is when the users have several standard metabolites that can have overlapping masses with unknown retention times. The standards with overlapping masses can be run separately using MS, resulting in different runs. MetaboIGNITER will help you to characterize this type of internal libraries. You will need to construct the Characterization file (see below) that shows which standards are present in which mzML file. The workflow will then do mass trace detection, MS2 extraction and mapping of parent ions to mass traces. Doing so will result in finding the retention time and empirical m/z of each standard. This will then be used to create identification parameters and search the biological MS2 files.\n\nSet the library parameter to true if you would like to perform library search:\n\n```nextflow\n    perform_identification_internal_library=true\n```\n\n## Output files\nThere will be a lot of different files generated by the workflow, if you are interested only in the final output part and identification information, please set this flag to false\n\n```nextflow\n    publishDir_intermediate\n```"
        },
        "openms_setting_files": {
            "title": "OpenMS setting files",
            "type": "object",
            "description": "Used for peak picking and feature detection",
            "default": "",
            "properties": {
                "peakpicker_ini_file_pos_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_peak_picker_ini_pos.ini",
                    "description": "Path to the ini file for PeakPickerHiRes"
                },
                "peakpicker_ini_file_neg_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_peak_picker_ini_neg.ini",
                    "description": "Path to the ini file for PeakPickerHiRes"
                },
                "featurefinder_ini_pos_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_feature_finder_metabo_ini_pos.ini",
                    "description": "Path to the ini file for OpenMS FeatureFinderMetabo in positive mode"
                },
                "featurefinder_ini_neg_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_feature_finder_metabo_ini_neg.ini",
                    "description": "Path to the ini file for OpenMS FeatureFinderMetabo in negative mode"
                },
                "peakpicker_ini_file_library_pos_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_peak_picker_lib_ini_pos.ini",
                    "description": "Path to the ini file for PeakPickerHiRes (for library)"
                },
                "peakpicker_ini_file_library_neg_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_peak_picker_lib_ini_neg.ini",
                    "description": "Path to the ini file for PeakPickerHiRes  (for library)"
                },
                "featurefinder_ini_library_pos_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_feature_finder_metabo_lib_ini_pos.ini",
                    "description": "Path to the ini file for OpenMS FeatureFinderMetabo in positive mode  (for library)"
                },
                "featurefinder_ini_library_neg_openms": {
                    "type": "string",
                    "default": "$baseDir/assets/openms/openms_feature_finder_metabo_lib_ini_neg.ini",
                    "description": "Path to the ini file for OpenMS FeatureFinderMetabo in negative mode  (for library)"
                }
            },
            "help_text": "These parameters are used to control OpenMS behaviour. If one chooses to perform centroiding, or mass trace detection using OpenMS (either in quantification or identification), these parameters should be tuned. \n\n**We only support OpenMS 2.4.0 at this stage**\n\n## Quantification using OpenMS\n\nIf you choose to perform the quantification using OpenMS, you should consider changing the parameters for OpenMS only. You can edit *openms_feature_finder_metabo_ini_pos.ini* and *openms_feature_finder_metabo_ini_neg.ini* files located under *metaboigniter/assets/openms*. The description of the parameters can be found on [OpenMS website](https://abibuilder.informatik.uni-tuebingen.de/archive/openms/Documentation/nightly/html/TOPP_FeatureFinderMetabo.html). **When tuning the OpenMS parameters make sure that \"report_convex_hulls\" is set to true**\n\nSimilarly, for centroiding, one can use the parameter files starting with *openms_peak_picker*. Please remember than you need to do this for both positive and negative ionization mode. \n\nYou can directly edit the in files in *metaboigniter/assets/*\n\n\n"
        },
        "quantification_input_files": {
            "title": "Quantification input files",
            "type": "object",
            "description": "Input files includes mzML files for performing quantification",
            "default": "",
            "properties": {
                "input": {
                    "type": "string",
                    "description": "Path to a folder containing mzML files used for doing quantification (MS1 data in positive ionization method)"
                },
                "quant_mzml_files_neg": {
                    "type": "string",
                    "description": "Path to a folder containing mzML files used for doing quantification (MS1 data in negative ionization method)"
                },
                "phenotype_design_pos": {
                    "type": "string",
                    "description": "Path to a csv file containing the experimental design (MS1 data in positive ionization method)"
                },
                "phenotype_design_neg": {
                    "type": "string",
                    "description": "Path to a csv file containing the experimental design (MS1 data in negative ionization method)"
                }
            },
            "required": [
                "input"
            ],
            "help_text": "you should first organize your mzML files into a folder structure. An example of such structure can be seen [here](https://github.com/nf-core/test-datasets/tree/metaboigniter). You don't have to follow the folder tree in the example. You just have to make sure that mzML files from different ionization are placed in different folders. If you only have one ionization mode (positive or negative), just put all the files in a single folder. If you have both, then create two folders, one for each of the ionization modes. For example if you want to follow our example, we create to folders called mzML_NEG_Quant and mzML_POS_Quant. Then the correponding files will be placed in each directory.\n\n```bash\n    Mydata\n    ├── mzML_NEG_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n    ├── mzML_POS_Quant\n    │   ├── Blank_1.mzML\n    │   ├── Blank_2.mzML\n    │   ├── Blank_3.mzML\n    │   ├── D1.mzML\n    │   ├── D2.mzML\n    │   ├── D3.mzML\n    │   ├── D4.mzML\n    │   ├── QC_1.mzML\n    │   ├── QC_2.mzML\n    │   ├── QC_3.mzML\n    │   ├── X1_Rep1.mzML\n    │   ├── X2_Rep1.mzML\n    │   ├── X3_Rep1.mzML\n    │   ├── X6_Rep1.mzML\n    │   ├── X7_Rep1.mzML\n    │   └── X8_Rep1.mzML\n```\n\nWhen you are ready with your folder structure you will need to set the parameters needed:\na glob path to a folder containing mzML files used for doing quantification (MS1 data in positive ionization method)\n\n```nextflow\n    input =\"\"\n```\na glob path to a folder containing mzML files used for doing quantification (MS1 data in negative ionization method)\n\n```nextflow\n    quant_mzml_files_neg=\"\"\n```\n\nfor example:\n\n```nextflow\n    input =\"/User/XXX/myfiles/pos_quant_data/*mzML\"\n```\n\n## Make phenotype file\n\nA phenotype is a CSV (comma separated file) representing a table showing metadata of the samples. Each row is one sample and each column is a meta field (columns are separated by comma). An example of such file can be found [here](https://raw.githubusercontent.com/MetaboIGNITER/test-datasets/master/phenotype_positive.csv). MetaboIGNITER expects a separate phenotype file for each ionization model. So if you have two ionization you will need to create two phenotype file.\nThis file is used to set class of the samples being analyzed. The file should have at least two column: the first column is showing the raw file name and extension (for example sample1.mzML) and the second column should show it's phenotype type. This file is a comma separated file and should container header (see the example):\n\n| RawFile        | Class    | Groups    | Type     | rename     | Technical repl   | Age   | Gender   |\n|--|--|--|--|--|--|--|--|\n| Sample1.mzML   | Sample   | Disease   | keep     | Disease1   | 1                | 35    | M        |\n| Sample2.mzML   | Sample   | Disease   | keep     | Disease2   | 1                | 35    | M        |\n| Sample3.mzML   | Sample   | Control   | keep     | Control1   | 2                | 37    | F        |\n| Sample4.mzML   | Sample   | Control   | keep     | Control2   | 2                | 37    | F        |\n| Blank1.mzML    | Blank    | NA        | remove   | NA         | NA               | NA    | NA       |\n| Blank2.mzML    | Blank    | NA        | remove   | NA         | NA               | NA    | NA       |\n| Blank3.mzML    | Blank    | NA        | remove   | NA         | NA               | NA    | NA       |\n| D1.mzML        | D1       | NA        | remove   | NA         | NA               | NA    | NA       |\n| D2.mzML        | D2       | NA        | remove   | NA         | NA               | NA    | NA       |\n| D3.mzML        | D3       | NA        | remove   | NA         | NA               | NA    | NA       |\n\nThe first column of this table must show the raw data file name (for example sample1.mzML). The file must have a header. Other information can also be added to this table such as age, gender, time etc. One can plan ahead and add even more information. In the example, we have added rename, technical replace and type. This information will be used later in the workflow to pre-process the samples. For example, Type can be used to filter out the samples not needed further down the pipeline. Rename can be us to rename the samples in the output file. Technical replicates can be used to average the samples that have been injected more than two times etc. The minimum number of columns is two showing the raw file name and class of the samples.\n\nPlease take your time and design the phenotype file so that you don't have to change it later. Pretty much all the steps of the workflow will depend on the correct designing of this file.\n\nWe included two examples of phenotype file in the [test data](https://github.com/nf-core/test-datasets/tree/metaboigniter). The files are called *phenotype_positive.csv* and *phenotype_negative.csv*. The example design, includes six biological samples, three blank samples (e.g, only the buffer were run), dilution samples (D1, D2 etc), in which a different dilution of samples have been run. QC samples that are the same replicate that was repeatedly run throughout the MS experiment.\n"
        },
        "generic_options": {
            "title": "Generic options",
            "type": "object",
            "fa_icon": "fas fa-file-import",
            "description": "Less common options for the pipeline, typically set in a config file.",
            "help_text": "These options are common to all nf-core pipelines and allow you to customise some of the core preferences for how the pipeline runs.\n\nTypically these options would be set in a Nextflow config file loaded for all pipeline runs, such as `~/.nextflow/config`.",
            "properties": {
                "help": {
                    "type": "boolean",
                    "description": "Display help text.",
                    "hidden": true,
                    "fa_icon": "fas fa-question-circle"
                },
                "publish_dir_mode": {
                    "type": "string",
                    "default": "copy",
                    "hidden": true,
                    "description": "Method used to save pipeline results to output directory.",
                    "help_text": "The Nextflow `publishDir` option specifies which intermediate files should be saved to the output directory. This option tells the pipeline what method should be used to move these files. See [Nextflow docs](https://www.nextflow.io/docs/latest/process.html#publishdir) for details.",
                    "fa_icon": "fas fa-copy",
                    "enum": [
                        "symlink",
                        "rellink",
                        "link",
                        "copy",
                        "copyNoFollow",
                        "move"
                    ]
                },
                "validate_params": {
                    "type": "boolean",
                    "description": "Boolean whether to validate parameters against the schema at runtime",
                    "default": true,
                    "fa_icon": "fas fa-check-square",
                    "hidden": true
                },
                "email_on_fail": {
                    "type": "string",
                    "description": "Email address for completion summary, only when pipeline fails.",
                    "fa_icon": "fas fa-exclamation-triangle",
                    "pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$",
                    "hidden": true,
                    "help_text": "This works exactly as with `--email`, except emails are only sent if the workflow is not successful."
                },
                "plaintext_email": {
                    "type": "boolean",
                    "description": "Send plain-text email instead of HTML.",
                    "fa_icon": "fas fa-remove-format",
                    "hidden": true,
                    "help_text": "Set to receive plain-text e-mails instead of HTML formatted."
                },
                "monochrome_logs": {
                    "type": "boolean",
                    "description": "Do not use coloured log outputs.",
                    "fa_icon": "fas fa-palette",
                    "hidden": true,
                    "help_text": "Set to disable colourful command line output and live life in monochrome."
                },
                "tracedir": {
                    "type": "string",
                    "description": "Directory to keep pipeline Nextflow logs and reports.",
                    "default": "${params.outdir}/pipeline_info",
                    "fa_icon": "fas fa-cogs",
                    "hidden": true
                },
                "show_hidden_params": {
                    "type": "boolean",
                    "fa_icon": "far fa-eye-slash",
                    "description": "Show all params when using `--help`",
                    "hidden": true,
                    "help_text": "By default, parameters set as _hidden_ in the schema are not shown on the command line when a user runs with `--help`. Specifying this option will tell the pipeline to show all parameters."
                }
            }
        },
        "max_job_request_options": {
            "title": "Max job request options",
            "type": "object",
            "fa_icon": "fab fa-acquisitions-incorporated",
            "description": "Set the top limit for requested resources for any single job.",
            "help_text": "If you are running on a smaller system, a pipeline step requesting more resources than are available may cause the Nextflow to stop the run with an error. These options allow you to cap the maximum resources requested by any single job so that the pipeline will run on your system.\n\nNote that you can not _increase_ the resources requested by any job using these options. For that you will need your own configuration file. See [the nf-core website](https://nf-co.re/usage/configuration) for details.",
            "properties": {
                "max_cpus": {
                    "type": "integer",
                    "description": "Maximum number of CPUs that can be requested    for any single job.",
                    "default": 16,
                    "fa_icon": "fas fa-microchip",
                    "hidden": true,
                    "help_text": "Use to set an upper-limit for the CPU requirement for each process. Should be an integer e.g. `--max_cpus 1`"
                },
                "max_memory": {
                    "type": "string",
                    "description": "Maximum amount of memory that can be requested for any single job.",
                    "default": "128.GB",
                    "fa_icon": "fas fa-memory",
                    "pattern": "^[\\d\\.]+\\s*.(K|M|G|T)?B$",
                    "hidden": true,
                    "help_text": "Use to set an upper-limit for the memory requirement for each process. Should be a string in the format integer-unit e.g. `--max_memory '8.GB'`"
                },
                "max_time": {
                    "type": "string",
                    "description": "Maximum amount of time that can be requested for any single job.",
                    "default": "240.h",
                    "fa_icon": "far fa-clock",
                    "pattern": "^[\\d\\.]+\\.*(s|m|h|d)$",
                    "hidden": true,
                    "help_text": "Use to set an upper-limit for the time requirement for each process. Should be a string in the format integer-unit e.g. `--max_time '2.h'`"
                }
            }
        },
        "institutional_config_options": {
            "title": "Institutional config options",
            "type": "object",
            "fa_icon": "fas fa-university",
            "description": "Parameters used to describe centralised config profiles. These should not be edited.",
            "help_text": "The centralised nf-core configuration profiles use a handful of pipeline parameters to describe themselves. This information is then printed to the Nextflow log when you run a pipeline. You should not need to change these values when you run a pipeline.",
            "properties": {
                "custom_config_version": {
                    "type": "string",
                    "description": "Git commit id for Institutional configs.",
                    "default": "master",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog",
                    "help_text": "Provide git commit id for custom Institutional configs hosted at `nf-core/configs`. This was implemented for reproducibility purposes. Default: `master`.\n\n```bash\n## Download and use config file with following git commit id\n--custom_config_version d52db660777c4bf36546ddb188ec530c3ada1b96\n```"
                },
                "custom_config_base": {
                    "type": "string",
                    "description": "Base directory for Institutional configs.",
                    "default": "https://raw.githubusercontent.com/nf-core/configs/master",
                    "hidden": true,
                    "help_text": "If you're running offline, nextflow will not be able to fetch the institutional config files from the internet. If you don't need them, then this is not a problem. If you do need them, you should download the files from the repo and tell nextflow where to find them with the `custom_config_base` option. For example:\n\n```bash\n## Download and unzip the config files\ncd /path/to/my/configs\nwget https://github.com/nf-core/configs/archive/master.zip\nunzip master.zip\n\n## Run the pipeline\ncd /path/to/my/data\nnextflow run /path/to/pipeline/ --custom_config_base /path/to/my/configs/configs-master/\n```\n\n> Note that the nf-core/tools helper package has a `download` command to download all required pipeline files + singularity containers + institutional configs in one go for you, to make this process easier.",
                    "fa_icon": "fas fa-users-cog"
                },
                "hostnames": {
                    "type": "string",
                    "description": "Institutional configs hostname.",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog"
                },
                "config_profile_name": {
                    "type": "string",
                    "description": "Institutional config name.",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog"
                },
                "config_profile_description": {
                    "type": "string",
                    "description": "Institutional config description.",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog"
                },
                "config_profile_contact": {
                    "type": "string",
                    "description": "Institutional config contact information.",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog"
                },
                "config_profile_url": {
                    "type": "string",
                    "description": "Institutional config URL link.",
                    "hidden": true,
                    "fa_icon": "fas fa-users-cog"
                }
            }
        }
    },
    "allOf": [
        {
            "$ref": "#/definitions/global_options"
        },
        {
            "$ref": "#/definitions/internal_library_quantification_and_identification_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/internal_library_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/output_preparation_negative_mode"
        },
        {
            "$ref": "#/definitions/cfm_id_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/metfrag_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/csi_fingerid_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/global_identification_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/adduct_and_isotope_annotation_negative_mode"
        },
        {
            "$ref": "#/definitions/filtering_parameters_negative_mode"
        },
        {
            "$ref": "#/definitions/quantification_parameter_negative_mode"
        },
        {
            "$ref": "#/definitions/internal_library_quantification_and_identification_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/internal_library_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/output_preparation_positive_mode"
        },
        {
            "$ref": "#/definitions/cfm_id_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/metfrag_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/csi_fingerid_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/global_identification_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/adduct_and_isotope_annotation_positive_mode"
        },
        {
            "$ref": "#/definitions/filtering_parameters_positive_mode"
        },
        {
            "$ref": "#/definitions/quantification_parameter_positive_mode"
        },
        {
            "$ref": "#/definitions/library_controls_and_files_negative_mode"
        },
        {
            "$ref": "#/definitions/library_controls_and_files_positive_mode"
        },
        {
            "$ref": "#/definitions/identification_input_files"
        },
        {
            "$ref": "#/definitions/control_parameters"
        },
        {
            "$ref": "#/definitions/openms_setting_files"
        },
        {
            "$ref": "#/definitions/quantification_input_files"
        },
        {
            "$ref": "#/definitions/generic_options"
        },
        {
            "$ref": "#/definitions/max_job_request_options"
        },
        {
            "$ref": "#/definitions/institutional_config_options"
        }
    ]
}
